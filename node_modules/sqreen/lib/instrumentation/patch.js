/**
 * Copyright (c) 2016 Sqreen. All Rights Reserved.
 * Please refer to our terms for more information: https://www.sqreen.io/terms.html
 */
'use strict';
const CB_STATUS = require('../enums/cbReturn').STATUS;
const Director = require('./sqreenDirector');
const CLS = require('continuation-local-storage');
const Logger = require('../logger');
const RuleUtil = require('../rules/rules-callback/utils');
const Attack = require('../constructors/attack');
const ReportUtil = require('./reportUtil');
const Metrics = require('../metric');
const Config = require('../config').getConfig() || {};
const Exception = require('../exception');
const Utils = require('../util');
const InstrumentationUtils = require('./utils');
const Feature = require('../command/features');
const PreConditions = require('./preConditions');

const HTTP_CODE = 'http_code';

const HeaderClaims = Utils.headerClaims;
const getHeaders = function (req) {

    // FIXME: should collect IP related claims
    if (!req.rawHeaders) {
        return [];
    }

    const result = [];
    const raw = req.rawHeaders;
    for (let i = 0; i < raw.length; ++i) {
        if (HeaderClaims.indexOf(raw[i].toLowerCase()) > -1) {
            result.push([raw[i], raw[i + 1]]);
        }
    }
    return result;
};

const countCB = function () {

    return !!Feature.read().call_counts_metrics_period;
};

const report = function (cbResult, err) {

    // TODO: put in setImmediate ?
    if (!cbResult) {
        return;
    }

    const session = cbResult.originalSession || cbResult.session || {};


    const atk = {
        rule_name: cbResult.rule && cbResult.rule.name,
        rulespack_id: cbResult.rule && cbResult.rule.rulesPack,
        infos: cbResult.record,
        params: session.req && ReportUtil.mapRequestParams(session.req),
        request: session.req && ReportUtil.mapRequest(session.req),

        block: cbResult.rule && cbResult.rule.block,
        test: cbResult.rule && cbResult.rule.test,
        beta: cbResult.rule && cbResult.rule.beta,
        learning: cbResult.rule && cbResult.rule.learning,

        headers: session.req && getHeaders(session.req)
    };

    atk.client_ip = Utils.getXFFOrRemoteAddress(session.req);

    atk.request = atk.request || {};
    atk.request.addr = atk.client_ip;

    (new Attack(atk, err)).report();
};

const observe = function (cbResult, date) {

    // It does not need to be done right now
    // setImmediate(() => {

    const observations = cbResult.observations;
    Metrics.addObservations(observations, date);
    // });
};

const performRecordAndObservation = function (resultList) {

    const date = new Date();
    const err = new Error();
    // setImmediate(() => {

    for (let i = 0; i < resultList.length; ++i) {
        const result = resultList[i];
        if (result.record) {
            report(result, err);
        }

        if (result.observations) {
            observe(result, date);
        }
    }
    // });
};

const actOnCbResult = function (resultList, session) {

    // modify args one day ? https://github.com/sqreen/Wiki/wiki/Sqreen-callbacks#pre
    if (resultList.length === 0) {
        return null;
    }
    // sometimes, the session is given from the callback: it is particular for the situation where the callback is placed on the eventEmitter and therefore executed BEFORE tracing is enabled
    // a solution would be to place tracing before on the request lifecyle but it would not be the smartest move (why place a tracing if the request/respose objects are always available and might have to be dropped ?)
    session = InstrumentationUtils.getListSession(resultList) || session;

    performRecordAndObservation(resultList);


    for (let i = 0; i < resultList.length; ++i) {

        const result = resultList[i];
        const rule = result.rule || {};

        if (result.status) {

            Logger.INFO(`Sqreen callback returned status ${result.status}`);
            Logger.DEBUG(`Sqreen callback result: ${result}`);

            if (!rule.test || Config.block_all_rules) {
                if (result.status === CB_STATUS.RAISE) {

                    if (session.req && session.res) {
                        RuleUtil.dropRequest(['', session.req, session.res]);
                        if (!session.req.__sqreen_uuid && Metrics.getMetricByName(HTTP_CODE)) { // the tracing has not been performed: the request has no id and no tail
                            performRecordAndObservation([{ observations: [[HTTP_CODE, 500, 1]] }]);
                        }
                    }
                    return Object.assign({}, result, { status: CB_STATUS.SKIP });
                }
                if (result.status === CB_STATUS.SKIP) {
                    return result;
                }
            }
        }
    }
    return null;
};

const runUniqueCb = function (method, args, value, rule, selfObject, session, kind) {

    if (!PreConditions.fillsPreConditions(rule, kind, args, value, selfObject, session)) {
        return {};
    }

    return tryThis(
        () => {

            const result = method(args, value, rule, selfObject, session) || {};
            result.session = session;
            result.rule = rule;
            result.params = { args, value };
            return result;
        },
        (e) => {

            // setImmediate(() => {

            let err = e;
            if (!err.stack) {
                err = new Error(err);
            }

            Logger.DEBUG(`cb has failed with ${err}`);
            rule = rule || {};
            err.ruleName = rule.name;
            err.rulesPack = rule.rulesPack;
            Exception.report(err).catch(() => {});
            // });
            return {};
        });
};

const runCbs = function (list, args, value, selfObject, kind, session) {

    if (session && session.req && session.req._sqreen_ip_whitelist) {
        return [];
    }

    if (process.__sqreen_cb) { // of the lock is present
        return null;
    }

    const length = list.length;

    const result = new Array(length);
    for (let i = 0; i < length; ++i) {
        if (!list[i].method) {
            result[i] = {};
            continue;
        }
        process.__sqreen_cb = true; // place a lock: two callbacks cannot run at the same time
        result[i] = runUniqueCb(list[i].method, args, value, list[i].rule, selfObject, session, kind);
        process.__sqreen_cb = false; // remove lock
    }

    // setImmediate(() => {

    logExec(list, kind);
    // });
    return result;
};

const ALL_PATCHES = [];
class Patch {

    constructor(original, moduleIdentity, holderName, key) {

        this.original = original;
        this.moduleIdentity = moduleIdentity;
        this.holderName = holderName;
        this.key = key;

        this.preCbs = [];
        this.failCbs = [];
        this.postCbs = [];
        this.hasCbs = false;

        this.instrumented = function () {};

        this.build();
        ALL_PATCHES.push(this);
    }

    register() {

        const self = this;
        Director.register({ // register the function for possible instrumentation
            moduleName: this.moduleIdentity.name,
            version: this.moduleIdentity.version,
            file: this.moduleIdentity.relativePath,
            methodName: this.holderName + (this.holderName ? ':' : '') + this.key,
            updateCallback: function (params) {

                Logger.DEBUG(`updating patch for ${self.moduleIdentity.name}/${self.moduleIdentity.relativePath}.${self.holderName + ':' + self.key}`);
                self.preCbs = params.preCbs || self.preCbs;
                self.failCbs = params.failCbs || self.failCbs;
                self.postCbs = params.postCbs || self.postCbs;
                self.hasCbs = (self.preCbs.length > 0 || self.failCbs.length > 0 || self.postCbs.length > 0);
            }
        });
    }

    runPre(arg, value, selfObject, session) {

        return runCbs(this.preCbs, arg, value, selfObject, 'pre', session);
    }

    runFail(arg, value, selfObject, session) {

        return runCbs(this.failCbs, arg, value, selfObject, 'fail', session);
    }

    runPost(arg, value, selfObject, session) {

        return runCbs(this.postCbs, arg, value, selfObject, 'post', session);
    }

    build() {

        const self = this;

        this.construct = function () {

            const res = new (Function.prototype.bind.apply(self.original, [null].concat(Array.from(arguments))))();
            if (Object.isExtensible(res)) {
                Object.defineProperty(res, '__sqreen_constructed', {
                    configurable: false,
                    enumerable: false,
                    writable: false,
                    value: true
                });
                Object.defineProperty(res, 'constructor', {
                    configurable: true,
                    enumerable: false,
                    writable: true,
                    value: self.instrumented
                });
            }
            return res;
        };

        this.instrumented = function () {

            const __sqreen_cb = process.__sqreen_cb;
            if (__sqreen_cb || !self.hasCbs) {
                if (this) {
                    const proto = Object.getPrototypeOf(this);
                    if (!this.__sqreen_constructed && proto && proto.constructor === self.original && proto.hasOwnProperty('constructor')) {
                        return self.construct.apply(this, arguments);
                    }
                }
                return self.original.apply(this, arguments);
            }

            const args = leakArgs.apply(this, arguments);
            const rawSession = CLS.getNamespace('sqreen_session') || { get: () => null };

            const session = {
                req: rawSession.get('req'),
                res: rawSession.get('res'),
                raw: rawSession
            };

            if (self.preCbs.length > 0){
                const preAction = actOnCbResult(self.runPre(args, null, this, session), session);
                if (preAction && preAction.status === CB_STATUS.SKIP) {
                    return preAction.newReturnValue;
                }
            }

            const result = tryThis(
                () => {

                    if (this) {
                        const proto = Object.getPrototypeOf(this);
                        if (!this.__sqreen_constructed && proto && proto.constructor === self.original && proto.hasOwnProperty('constructor')) {
                            return self.construct.apply(this, args);
                        }
                    }
                    return self.original.apply(this, args);
                },
                (err) => {

                    if (self.failCbs.length > 0) {
                        const failAction = actOnCbResult(self.runFail(args, err, this, session), session);
                        if (failAction && failAction.status === CB_STATUS.SKIP) {
                            return failAction.newReturnValue;
                        }
                    }
                    throw err;
                });

            if (self.postCbs.length > 0) {
                const postAction = actOnCbResult(self.runPost(args, result, this, session), session);
                if (postAction && postAction.status === CB_STATUS.SKIP) {
                    return postAction.newReturnValue;
                }
            }
            return result;
        };

        Object.setPrototypeOf(this.instrumented, Object.getPrototypeOf(this.original));
        if (this.original.prototype) {
            Object.setPrototypeOf(this.instrumented.prototype, Object.getPrototypeOf(this.original.prototype));
        }

        const memberList = Object.getOwnPropertyNames(this.original);
        for (let i = 0; i < memberList.length; ++i) {
            Object.defineProperty(this.instrumented, memberList[i], Object.getOwnPropertyDescriptor(this.original, memberList[i]));
        }
        this.register();
    }
}

const leakArgs = function () {

    return arguments;
};

const tryThis = function (exec, fail) {

    try {
        return exec();
    }
    catch (err) {
        return fail(err);
    }
};

const callCount = {};
const logExec = function (cbList, kind) {

    // setImmediate(() => {

    if (!countCB()) {
        return;
    }

    for (let i = 0; i < cbList.length; ++i){
        const rule = cbList[i].rule || {};

        const interval = rule.call_count_interval;
        if (!interval) {
            continue;
        }
        const key =  `${rule.rulesPack}/${rule.name}/${kind}`;


        if (callCount[key] >= interval - 1) {

            Metrics.addObservations([
                [
                    'sqreen_call_counts',
                    key,
                    interval
                ]
            ], new Date());
            callCount[key] = 0;
        }
        else {
            callCount[key] = callCount[key] + 1 || 1;
        }
    }
    // });
};

module.exports = Patch;
module.exports._runCbs = runCbs;
module.exports._report = report;
module.exports._actOnCbResult = module.exports.actOnCbResult = actOnCbResult;
module.exports.removeAllCallbacks = function () {

    Director.clearWaitings();
    for (let i = 0; i < ALL_PATCHES.length; ++i) {
        const patch = ALL_PATCHES[i];
        patch.hasCbs = false;
        patch.preCbs = [];
        patch.failCbs = [];
        patch.postCbs = [];
    }
};
module.exports._logExec = logExec;
