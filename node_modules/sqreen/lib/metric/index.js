/**
 * Copyright (c) 2016 Sqreen. All Rights Reserved.
 * Please refer to our terms for more information: https://www.sqreen.io/terms.html
 */
'use strict';
let METRIC_STORE = {};
const Exception = require('../exception');

const getName = function (metric)  {

    return metric.name;
};

module.exports = class {

    constructor(metric) {

        const name = getName(metric);
        if (METRIC_STORE[name]) {
            throw new Error('metric exists');
        }
        this.name = name;
        this.metricName = metric.name;
        this.values = [];
        this.currentValue = {};
        this.timestamp = new Date();
        this.period = metric.period * 1000;

        METRIC_STORE[name] = this;
    }

    process(date, force) {

        const now = new Date();
        date = date || now;

        if (date - this.timestamp > this.period || force) {
            if (this.build) {
                this.build();
            }
            this.values.push({
                start: this.timestamp,
                finish: now,
                value: this.currentValue
            });
            this.currentValue = {};
            this.timestamp = now;
        }
        return this.currentValue;
    }

    observe(force) {

        this.process(null, force);
        const result = this.values;
        this.values = [];
        return result;
    }

    get report() {

        // no breaking changes
        return this.getReport(false);
    };

    getReport(force) {

        const observation = this.observe(force);
        const self = this;
        return observation.map((obs) => ({
            observation: obs.value,
            start: obs.start,
            finish: obs.finish,
            name: self.metricName
        }));
    };
};

const METRIC_KINDS = {
    Sum: require('./sum'),
    Average: require('./average'),
    Collect: require('./collect')
};

module.exports.getMetric = function (metric) {

    metric = metric || {};

    const name = getName(metric);
    if (METRIC_STORE[name]) {
        METRIC_STORE[name].period = metric.period * 1000;
        return METRIC_STORE[name];
    }
    if (METRIC_KINDS[metric.kind]) {
        return new METRIC_KINDS[metric.kind](metric);
    }
    return null;

};

module.exports.getName = getName;
module.exports.getMetricByName = function (name) {

    return METRIC_STORE[name];
};

module.exports._clearAllMetrics = function () {

    METRIC_STORE = {};
};

module.exports.addObservations = function (observationList, date) {

    observationList
        .forEach((obs) => {

            if (METRIC_STORE[obs[0]]) {
                METRIC_STORE[obs[0]].add.apply(METRIC_STORE[obs[0]], obs.slice(1).concat([date]));
            }
            else {
                Exception.report(new Error(`unregistered metric: ${obs[0]}`)).catch(() => Promise.resolve());
            }
        });
};

module.exports.getAllReports = function (force) {

    return Object.keys(METRIC_STORE)
        .map((metricName) => METRIC_STORE[metricName].getReport(force))
        .reduce((a, b) => a.concat(b), [])
        .filter((obs) => Object.keys(obs.observation).length > 0);
};
