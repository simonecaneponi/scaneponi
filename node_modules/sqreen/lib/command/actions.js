/**
 * Copyright (c) 2016 Sqreen. All Rights Reserved.
 * Please refer to our terms for more information: https://www.sqreen.io/terms.html
 */
/**
 * This is the list of the known commands and the related handlers
 */
'use strict';
const Logger = require('../logger');
const BackEnd = require('../backend');
const Agent = require('../agent');
const Features = require('./features');
const IpWhitelist = require('../instrumentation/whitelist');
const Login = require('../backend/login');

const commands = {
    mock: function () { // For testing purpose

        return Promise.resolve();
    },
    mock_fail: function () { // For testing purpose

        return Promise.reject();
    },
    mock_fail_err: function () { // For testing purpose

        return Promise.reject(new Error('aa'));
    },
    instrumentation_enable: function (params, uuid) {

        Logger.DEBUG(`enables instrumentation with uuid ${uuid}`);
        return commands.rules_reload();
    },
    rules_reload: function (params, uuid) {

        Logger.DEBUG(`reload rulespack with uuid ${uuid}`);

        if (!Agent.SESSION_ID()) {
            return Promise.reject(new Error('agent is offline'));
        }
        return BackEnd.rulespack(Agent.SESSION_ID())
            .then((response) => {

                if (!response.pack_id) {
                    return '';
                }
                // const pack_id = response.pack_id; // TODO: track it
                const rules = response.rules;
                for (let i = 0; i < rules.length; ++i) {
                    rules[i].rulesPack = response.pack_id;
                }
                Logger.INFO(`got a new rulepack with ${rules.length} rules`);

                // remove all callbacks everywhere before reloading rules
                const Patch = require('../instrumentation/patch');
                Patch.removeAllCallbacks();

                const Rules = require('../rules'); // load here and not at the beginning of the script to prevent circular import issue
                const result = Rules.enforceRuleList(rules);

                if (!result) {
                    return Promise.reject(new Error(`invalid rulespack: ${response.pack_id}`));
                }

                return response.pack_id;
            });
    },
    instrumentation_remove: function (params, uuid) {

        Logger.INFO(`disabling instrumentation with uui ${uuid}`);
        const Patch = require('../instrumentation/patch');
        Patch.removeAllCallbacks();
        return Promise.resolve();
    },
    features_change: function (params, uuid) {

        Logger.INFO(`changing features to ${JSON.stringify(params)} with id ${uuid}`);
        return Promise.resolve(Features.change(params));
    },
    features_get: function (params, uuid) {

        Logger.INFO(`getting features to ${JSON.stringify(params)} with id ${uuid}`);
        return Promise.resolve(Features.read());
    },
    paths_whitelist: function (params, uuid) {

        if (!params[0] || !Array.isArray(params[0])) {
            return Promise.reject(new Error('invalid params'));
        }
        Logger.INFO(`Whitelisting paths ${params[0].join(',')} with uui ${uuid}`);
        const Whitelist = require('../instrumentation/whitelist');
        Whitelist.whitelistThesePaths(params[0]);
        return Promise.resolve();
    },
    force_logout: function (params, uuid) {

        // event drain is made at logout

        return commands.instrumentation_remove(params, uuid)
            .then(() => Agent.stop());
    },
    ips_whitelist: function (params, uuid) {

        Logger.INFO(`Whitelisting ips ${params[0].join(',')} with uui ${uuid}`);
        IpWhitelist.whitelistTheseIPs(params[0]);
        return Promise.resolve();
    },
    get_bundle: function (params, uuid) {

        Logger.INFO(`Collecting bundle with uui ${uuid}`);
        const Reader = require('../package-reader');

        const promiseDepsHash = function () {

            return new Promise((resolve) => {

                Reader.getDependenciesHash((hash) => {

                    return resolve(hash);
                });
            });
        };

        const pkg = Login.getPkg();
        const declared = {};
        if (pkg) {
            declared.dependencies = pkg.dependencies;
            declared.devDependencies = pkg.devDependencies;
        }

        return Promise.all([promiseDepsHash(), Reader.getDependencies()])
            .then((res) => BackEnd.bundle(Agent.SESSION_ID(), { bundle_signature: res[0], dependencies: res[1], declared }));
    }
};
module.exports = commands;
