/**
 * Copyright (c) 2016 Sqreen. All Rights Reserved.
 * Please refer to our terms for more information: https://www.sqreen.io/terms.html
 */
'use strict';
const Code = require('code');
const Lab = require('lab');
const lab = exports.lab = Lab.script();
const beforeEach = lab.beforeEach;

const describe = lab.describe;
const it = lab.it;
const expect = Code.expect;

const Metric = require('../../../lib/metric');

describe('Metric', () => {

    beforeEach((done) => {

        Metric._clearAllMetrics();
        done();
    });

    it('should accept to create a new metric', { plan: 1 }, (done) => {

        const metric = new Metric({
            kind: 'Sum',
            name: 'login-fail',
            period: 10
        });

        expect(Metric.getMetricByName('login-fail')).to.equal(metric);
        done();
    });

    it('should refuse to create a new metric', { plan: 2 }, (done) => {

        const metric = new Metric({
            kind: 'Sum',
            name: 'login-fail',
            period: 10
        });

        expect(Metric.getMetricByName('login-fail')).to.equal(metric);

        try {
            new Metric({
                kind: 'Sum',
                name: 'login-fail',
                period: 10
            });
        }
        catch (err) {
            expect(err).to.exist();
            done();
        }
    });

    it('should accept to create a new metric and store data', { plan: 3, timeout: 20000 }, (done) => {

        const metric = new Metric({
            kind: 'Sum',
            name: 'login-fail',
            period: 2
        });

        metric.process();
        metric.currentValue = 1;

        setTimeout(() => {

            metric.process();
            metric.currentValue = 2;
        }, 3000);

        setTimeout(() => {

            expect(metric.values.map((x) => x.value)).to.equal([1]);
            expect(metric.observe().map((x) => x.value)).to.equal([1, 2]);
            expect(metric.values).to.equal([]);
            done();
        }, 6000);
    });

    it('should accept to create a new metric, store data and get reportable data', { plan: 5, timeout: 20000 }, (done) => {

        const metric = new Metric({
            kind: 'Sum',
            name: 'login-fail',
            period: 2
        });

        metric.process();
        metric.currentValue = { id: 1 };

        setTimeout(() => {

            metric.process();
            metric.currentValue = { id: 2 };
        }, 3000);

        setTimeout(() => {

            metric.process();
            expect(metric.values.map((x) => x.value)).to.equal([{ id: 1 }, { id: 2 }]);

            const report = metric.report;
            expect(report[0].observation).to.equal({ id: 1 });
            expect(Math.abs(3000 - (report[0].finish - report[0].start))).to.be.below(10);
            expect(report[1].observation).to.equal({ id: 2 });
            expect(metric.values).to.equal([]);
            done();
        }, 6000);
    });

    it('should accept to create a new metric, store data and get reportable data through getAllReports', { plan: 8, timeout: 20000 }, (done) => {

        const metric = new Metric({
            kind: 'Sum',
            name: 'login-fail',
            period: 2
        });

        const metric2 = new Metric({
            kind: 'Sum',
            name: 'login-success',
            period: 2
        });

        metric.process();
        metric.currentValue = { id: 1 };
        metric2.currentValue = { id: 1 };

        setTimeout(() => {

            metric.process();
            metric.currentValue = { id: 2 };
        }, 3000);

        setTimeout(() => {

            metric.process();
            expect(metric.values.map((x) => x.value)).to.equal([{ id: 1 }, { id: 2 }]);

            const reports = Metric.getAllReports();
            expect(reports).to.have.length(3);
            expect(reports[0].name).to.equal('login-fail');
            expect(reports[0].observation).to.equal({ id: 1 });

            expect(reports[1].name).to.equal('login-fail');
            expect(reports[1].observation).to.equal({ id: 2 });

            expect(reports[2].name).to.equal('login-success');
            expect(reports[2].observation).to.equal({ id: 1 });

            done();
        }, 6000);
    });

    describe('addObservations', () => {

        it('should create a new metric and add observations to it', { plan: 3, timeout: 5000 }, (done) => {

            const rule = {
                name: 'rule',
                metrics: [
                    {
                        kind: 'Sum',
                        name: 'test',
                        period: 2
                    },
                    {
                        kind: 'none',
                        name: 'none',
                        period: 15
                    }
                ]
            };

            rule.metrics.forEach(Metric.getMetric);

            const observations = [['test', 'unicorn', 1], ['test', 'pony', 2], ['none', 'nono', 10]];

            Metric.addObservations(observations);
            Metric.addObservations([['test', 'unicorn', 1]]);
            const noneMetric = Metric.getMetricByName(Metric.getName(rule.metrics[1]));
            const metric = Metric.getMetricByName(Metric.getName(rule.metrics[0]));

            expect(noneMetric).to.not.exist();
            expect(metric).to.exist();
            setTimeout(() => {

                const result = metric.observe();
                expect(result.map((r) => r.value)).to.equal([{ 'unicorn': 2, 'pony': 2 }]);
                done();
            }, 3000);

        });
    });

});
