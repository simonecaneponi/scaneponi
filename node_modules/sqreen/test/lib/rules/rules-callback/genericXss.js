/**
 * Copyright (c) 2016 Sqreen. All Rights Reserved.
 * Please refer to our terms for more information: https://www.sqreen.io/terms.html
 */
'use strict';
const Code = require('code');
const Lab = require('lab');
const lab = exports.lab = Lab.script();

const describe = lab.describe;
const it = lab.it;
const expect = Code.expect;

const GetCB = require('../../../../lib/rules/rules-callback').GenericXSSCB;
const Sanitize = require('../../../../lib/rules/rules-callback/genericXss')._sanitize;
const Proxyquire = require('proxyquire');

describe('GenericXSSCB', () => {

    describe('sanitize', () => {

        it('should sanitize an object', { plan: 2 }, (done) => {

            const x1 = { a: 'a', b: 'b', c: { d: 'd' } };
            Sanitize(x1, ['b']);
            expect(x1).to.equal({ a: '__', b: 'b', c: { d: '__' } });

            const x2 = { a: 'a', b: 'b' };
            Sanitize(x2);
            expect(x2).to.equal({ a: '__', b: '__' });
            done();
        });
    });

    it('should get the callback and test it', { plan: 1 }, (done) => {

        const fct = function () {

            return null;
        };
        const CB = GetCB({
            callbacks: {
                pre: [
                    null,
                    null,
                    fct.toString()
                ]
            }
        }).pre;

        const selfObject = {
            render: {
                __original: function (a, cb) {

                    cb(null, '');
                    done();
                }
            }
        };

        const args = [null, function (err) {

            expect(err).to.not.exist();
        }];

        const cbArgs = [args, null, {}, selfObject, {}];
        CB.apply(null, cbArgs);
        cbArgs[0][1](null, '');
    });

    it('should get the callback and test it with xss', { plan: 3 }, (done) => {

        const fct = function () {

            return {
                name: 'script',
                attribs: { x: 'y' }
            };
        };
        const CB = Proxyquire('../../../../lib/rules/rules-callback/genericXss', {
            '../../instrumentation/patch': {
                _actOnCbResult: function (result) {

                    const res = result[0];
                    expect(res).to.exist();
                    expect(res.record.payload).to.equal('<script x="y"></script>');
                    done();
                }
            }
        })
            .getCbs({
                callbacks: {
                    pre: [
                        null,
                        null,
                        fct.toString()
                    ]
                }
            }).pre;

        const selfObject = {
            render: {
                __original: function (a, cb) {

                    cb(null, '');
                }
            }
        };

        const args = [null, function (err) {

            expect(err).to.not.exist();
        }];

        const cbArgs = [args, null, {}, selfObject, {}];
        CB.apply(null, cbArgs);
        cbArgs[0][1](null, '');
    });

    it('should not do anything since arg is not a function', { plan: 0 }, (done) => {

        const fct = function () {

            return null;
        };
        const CB = GetCB({
            callbacks: {
                pre: [
                    null,
                    null,
                    fct.toString()
                ]
            }
        }).pre;

        const cbArgs = [[null, null, null], null, {}, {}, {}];
        CB.apply(null, cbArgs);
        done();
    });

    it('should handle case with errors in first render', { plan: 1 }, (done) => {

        const fct = function () {

            throw new Error('should have not run');
        };
        const CB = GetCB({
            callbacks: {
                pre: [
                    null,
                    null,
                    fct.toString()
                ]
            }
        }).pre;

        const selfObject = {
            render: {
                __original: function () {

                    throw new Error('should have not run');
                }
            }
        };

        const args = [null, function (err) {

            expect(err).to.exist();
        }];

        const cbArgs = [args, null, {}, selfObject, {}];
        CB.apply(new Error(), cbArgs);
        cbArgs[0][1](new Error(), '');
        done();
    });

    it('should handle case with errors in second render', { plan: 1 }, (done) => {

        const fct = function () {

            throw new Error('should have not run');
        };
        const CB = GetCB({
            callbacks: {
                pre: [
                    null,
                    null,
                    fct.toString()
                ]
            }
        }).pre;

        const selfObject = {
            render: {
                __original: function (a, cb) {

                    return cb(new Error());
                }
            }
        };

        const args = [null, function (err) {

            expect(err).to.not.exist();
        }];

        const cbArgs = [args, null, {}, selfObject, {}];
        CB.apply(new Error(), cbArgs);
        cbArgs[0][1](null, '');
        done();
    });
});
