/**
 * Copyright (c) 2016 Sqreen. All Rights Reserved.
 * Please refer to our terms for more information: https://www.sqreen.io/terms.html
 */
'use strict';
const Code = require('code');
const Lab = require('lab');
const lab = exports.lab = Lab.script();

const describe = lab.describe;
const it = lab.it;
const expect = Code.expect;

const Utils = require('../../../../lib/rules/rules-callback/utils');
const Clean = Utils.asJson;
const Http = require('http');

describe('Utils', () => {

    describe('dropRequest', () => {

        it('should change the arguments', { plan: 5 }, (done) => {

            const args1 = {
                socket: {
                    end: function () {

                        expect(true).to.be.true(); // ensure call
                    }
                }
            };
            const args2 = {
                writeHead: function (code) {

                    expect(code).to.equal(500);
                },
                end: function () {

                    expect(true).to.be.true(); // ensure call
                }

            };

            const args = { '0': null, '1': args1 , '2': args2  };
            Utils.dropRequest(args);
            expect(args[1]).to.be.an.instanceof(Http.IncomingMessage);
            expect(args[1].method).to.equal('OPTIONS');
            done();
        });

        it('should change the arguments and call sqreen end', { plan: 5 }, (done) => {

            const args1 = {
                socket: {
                    end: function () {

                        expect(true).to.be.true(); // ensure call
                    }
                }
            };
            const args2 = {
                writeHead: function (code) {

                    expect(code).to.equal(500);
                },
                __original_end: function () {

                    expect(true).to.be.true(); // ensure call
                }

            };

            const args = { '0': null, '1': args1 , '2': args2  };
            Utils.dropRequest(args);
            expect(args[1]).to.be.an.instanceof(Http.IncomingMessage);
            expect(args[1].method).to.equal('OPTIONS');
            done();
        });
    });

    describe('getLookableClaims', () => {

        // remove cache atm, see comment in code
        it.skip('should get a cached of request object', { plan: 1 }, (done) => {

            const input = { __sqreen_lookable: { a: 'a' } };
            const output = input.__sqreen_lookable;
            expect(Utils.getLookableClaims(input)).to.equal(output);
            done();
        });

        it('should get a new version of request object', { plan: 1 }, (done) => {

            const input = { query: 'aaa', socket: {}, connection: { remoteAddress: '127.0.0.1' } };
            const output = { query: 'aaa', connection: { remoteAddress: '127.0.0.1' } };
            expect(Utils.getLookableClaims(input)).to.equal(output);
            done();
        });

        it('should get a new version of request object with sqreen hold', { plan: 1 }, (done) => {

            const input = { __sqreen: { lookup: { a: 1 } } };
            const output = { __sqreen_lookup: { a:1 } };
            expect(Utils.getLookableClaims(input)).to.equal(output);
            done();
        });

        it('should get a new version of request object with sqreen hold', { plan: 1 }, (done) => {

            const input = { __sqreen: { lookup: { a: 1 }, hapi: [] } };
            const output = { __sqreen_lookup: { a:1 } };
            expect(Utils.getLookableClaims(input)).to.equal(output);
            done();
        });


        it('should get a new version of request object with sqreen hold and hapi stuff', { plan: 1 }, (done) => {

            const input = { __sqreen: { hapi: [{ value: { params: 'a', query: 'b', payload: 'c' } }] } };
            const output = { __sqreen_lookup: { hapi: { params: 'a', query: 'b', payload: 'c' } } };
            expect(Utils.getLookableClaims(input)).to.equal(output);
            done();
        });
    });

    describe('findLoginArtifact', () => {

        it('should find something or not', { plan: 3 }, (done) => {

            expect(Utils.findLoginArtifact({ emailAddress: 'unicorn@sqreen.io' })).to.equal({ key: 'emailAddress', value: 'unicorn@sqreen.io' });
            expect(Utils.findLoginArtifact({ emailAddress: '' })).to.equal({});
            expect(Utils.findLoginArtifact({ })).to.equal({});

            done();
        });

        it('should find something or not in a mongoose like object', { plan: 2 }, (done) => {

            class model {

                constructor(emailAddress) {

                    this._doc = {
                        emailAddress
                    };
                }
            }

            expect(Utils.findLoginArtifact(new model('unicorn@sqreen.io'))).to.equal({ key: 'emailAddress', value: 'unicorn@sqreen.io' });

            const item = new model('unicorn@sqreen.io');
            item.constructor = null;
            expect(Utils.findLoginArtifact(item)).to.equal({});
            done();
        });
    });
});

describe('Clean', () => {

    const fct1 = function () {};
    fct1.a = 1;

    const cyclic = { a: { b: { c: {} } }, a1: 1 };
    cyclic.a.b.c = cyclic;

    const cyclicfct = function () {};
    cyclicfct.a = { b: { c: {} } };
    cyclicfct.a.b.c = cyclicfct;

    const ro = { a: 1 };
    Object.defineProperty(ro, 'b', {
        enumerable: true,
        get: function () {

            return 2;
        }
    });
    let val = 5;
    Object.defineProperty(ro, 'c', {
        enumerable: true,
        get: function () {

            return val;
        },
        set: function () {

            val++;
        }
    });

    const tests = [
        {
            input: { a: 1 }, output: { a: 1 }
        },
        {
            input: { a: [1] }, output: { a: [1] }
        },
        {
            input: { a: 1, b: 0, c: function () {} }, output: { a: 1, b: 0, c: {} }
        },
        {
            input: { a: 1, b: 2, c: fct1 }, output: { a: 1, b: 2, c: { a: 1 } }
        },
        {
            input: cyclic, output: { a: { b: { c: { } } }, a1: 1 }
        },
        {
            input: cyclicfct, output: { a: { b: { c: { } } } }
        },
        {
            input: ro, output: ro
        },
        {
            input: { userName: { $gt: '' } }, output: { userName: { $gt: '' } }
        },
        {
            input: { a: null, b: undefined }, output: { a: {}, b: {} }
        },
        {
            input: ['a', 'b'], output: ['a', 'b']
        }
    ];

    tests.forEach((item, rank) => {

        it(`should transform item ${rank}`, { plan: 1 }, (done) => {

            expect(Clean(item.input)).to.equal(item.output);
            done();
        });
    });


});
