/**
 * Copyright (c) 2016 Sqreen. All Rights Reserved.
 * Please refer to our terms for more information: https://www.sqreen.io/terms.html
 */
'use strict';
const Code = require('code');
const Lab = require('lab');
const lab = exports.lab = Lab.script();

const describe = lab.describe;
const it = lab.it;
const expect = Code.expect;

const Proxyquire = require('proxyquire');
const Rules = require('../../../lib/rules/index');

describe('Rules', () => {

    describe('_UpdatePayload', () => {

        it('should finish covering', { plan: 1 }, (done) => {

            const point =  new Rules._UpdatePayload({});
            point.getCallbacks.push(() => ({ callbacks: { post: 'xxx' } }));

            point.build();

            expect(point.params.postCbs[0].method).to.equal('xxx');
            done();
        });
    });

    describe('_getHookPoint', () => {

        it('should slice the full module', { plan: 5 }, (done) => {

            const result = Rules._getHookPoint({ klass: 'module#version:file', method: 'method' });

            expect(result.moduleName).to.equal('module');
            expect(result.methodName).to.equal('method');
            expect(result.file).to.equal('file');
            expect(result.versions).to.equal('version');
            expect(result.target).to.equal('module#version:file::method');

            done();

        });

        it('should slice the module', { plan: 5 }, (done) => {

            const result = Rules._getHookPoint({ klass: 'module#version', method: '' });

            expect(result.moduleName).to.equal('module');
            expect(result.methodName).to.equal('');
            expect(result.file).to.equal('');
            expect(result.versions).to.equal('version');
            expect(result.target).to.equal('module#version::');

            done();

        });

        it('should slice the module', { plan: 5 }, (done) => {

            const result = Rules._getHookPoint({ klass: 'module', method: 'method' });

            expect(result.moduleName).to.equal('module');
            expect(result.methodName).to.equal('method');
            expect(result.file).to.equal('');
            expect(result.versions).to.equal('');
            expect(result.target).to.equal('module::method');

            done();

        });

        it('should slice the module', { plan: 5 }, (done) => {

            const result = Rules._getHookPoint({ klass: 'module:file', method: 'method' });

            expect(result.moduleName).to.equal('module');
            expect(result.methodName).to.equal('method');
            expect(result.file).to.equal('file');
            expect(result.versions).to.equal('');
            expect(result.target).to.equal('module:file::method');

            done();

        });
    });

    describe('_getCallbacks', () => {

        it('should return a callback method', { plan: 2 }, (done) => {

            const result = Rules._getCallbacks({ hookpoint: { callback_class: 'HeadersInsertCB' } });
            expect(result.post).to.not.exist();
            expect(result.pre).to.exist();

            done();
        });

        it('should throw', { plan: 1 }, (done) => {

            try {
                Rules._getCallbacks({ hookpoint: { } });
            }
            catch (err) {
                expect(err).to.exist();
                done();
            }
        });

        it('shoud call the builder', { plan: 1 }, (done) => {

            const fct = function () {};

            const MockedRules = Proxyquire('../../../lib/rules/index', {
                './rules-callback/callbackBuilder': {
                    getCbs: () => fct
                }
            });
            const result = MockedRules._getCallbacks({ callbacks: 'anything', hookpoint: {} });
            expect(result).to.equal(fct);
            done();
        });

    });

    describe('_loadRuleList', () => {

        it('should read a list of rules', { plan: 4 }, (done) => {

            const MockedRules = Proxyquire('../../../lib/rules/index', {
                './reader': {
                    verifyRule: () => true
                },
                '../exception': {
                    report: function (err) {

                        expect(err).to.exist();
                        return Promise.reject(err);
                    }
                }
            });

            const result = MockedRules._loadRuleList([
                {},
                {
                    hookpoint: {
                        klass: 'module',
                        callback_class: 'HeadersInsertCB'
                    }
                }
            ]);

            expect(result).to.be.an.array();
            expect(result).to.have.length(1);
            expect(result[0].target).to.equal('module::');
            done();
        });
    });

    describe('_collectHookPointsInstructions', () => {

        it('should collect a generated list of hookpoints', { plan: 1 }, (done) => {

            const MockedRules = Proxyquire('../../../lib/rules/index', {
                './reader': {
                    verifyRule: () => true
                },
                '../exception': {
                    report: function () {}
                }
            });

            const hpl = MockedRules._loadRuleList([
                {
                    hookpoint: {
                        klass: 'module',
                        callback_class: 'HeadersInsertCB'
                    }
                }
            ]);

            const result = Rules._collectHookPointsInstructions(hpl);

            expect(result['module::']).to.exist();

            done();
        });

        it('should collect a list of hookpoints', { plan: 9 }, (done) => {

            const hpl = [
                {
                    target: 'module::',
                    versions: '',
                    rule: 'rule',
                    moduleName: 'module',
                    methodName: '',
                    file: '',
                    getCallbacks: () => ({
                        callbacks: {
                            pre: 'pre0',
                            post: 'post0'
                        },
                        rule: 'rule'
                    })
                },
                {
                    target: 'module::',
                    versions: '',
                    rule: 'rule',
                    moduleName: 'module',
                    methodName: '',
                    file: '',
                    getCallbacks: () => ({
                        callbacks: {
                            pre: 'pre1',
                            post: 'post1',
                            fail: 'fail1'
                        },
                        rule: 'rule'
                    })

                },
                {
                    target: 'module::method',
                    versions: '',
                    rule: 'rule',
                    moduleName: 'module',
                    methodName: 'method',
                    file: '',
                    getCallbacks: () => ({
                        callbacks: {
                            pre: 'pre2',
                            fail: 'fail3'
                        },
                        rule: 'rule'
                    })
                }
            ];

            const result = Rules._collectHookPointsInstructions(hpl);

            expect(result['module::']).to.exist();
            expect(result['module::method']).to.exist();
            expect(result['module::'].params).to.exist();

            result['module::'].build();

            expect(result['module::'].params.preCbs).to.equal([{ method: 'pre0', rule: 'rule' }, { method: 'pre1', rule: 'rule' }]);
            expect(result['module::'].params.postCbs).to.equal([{ method: 'post1', rule: 'rule' }, { method: 'post0', rule: 'rule' }]);
            expect(result['module::'].params.failCbs).to.equal([{ method: 'fail1', rule: 'rule' }]);

            result['module::method'].build();
            expect(result['module::method'].params.preCbs).to.equal([{ method: 'pre2', rule: 'rule' }]);
            expect(result['module::method'].params.postCbs).to.equal([]);
            expect(result['module::method'].params.failCbs).to.equal([{ method: 'fail3', rule: 'rule' }]);


            done();
        });

        describe('enforceRuleList', () => {

            it('should not do anything if the rulelist is empty', { plan: 1 }, (done) => {

                const MockedRules = Proxyquire('../../../lib/rules/index', {
                    './reader': {
                        verifyRule: () => done(new Error('should have failed'))
                    }
                });

                expect(MockedRules.enforceRuleList([])).to.be.false();
                done();
            });

            it('should enforce a rule list', { plan: 8 }, (done) => {

                const MockedRules = Proxyquire('../../../lib/rules/index', {
                    './reader': {
                        verifyRule: () => true
                    },
                    '../exception': {
                        report: function () {}
                    },
                    '../instrumentation/sqreenDirector': {
                        update: function (payload) {

                            expect(payload.file).to.equal('file');
                            expect(payload.methodName).to.equal('method');
                            expect(payload.moduleName).to.equal('module');
                            expect(payload.versions).to.equal('version');

                            payload.build();

                            expect(payload.params.preCbs).to.be.an.array();
                            expect(payload.params.preCbs).to.have.length(1);

                            const Metric = require('../../../lib/metric');
                            expect(Metric.getMetricByName('crawler')).to.exist();
                            expect(Metric.getMetricByName('crawler').period).to.equal(60000);

                            done();
                        }
                    }
                });

                MockedRules.enforceRuleList([
                    {
                        hookpoint: {
                            klass: 'module#version:file',
                            method: 'method',
                            callback_class: 'HeadersInsertCB'
                        },
                        metrics: [
                            {
                                kind: 'Sum',
                                name: 'crawler',
                                period: 60
                            }
                        ]
                    }
                ]);
            });

            it('should enforce a rule list that raise', { plan: 0 }, (done) => {

                const MockedRules = Proxyquire('../../../lib/rules/index', {
                    './reader': {
                        verifyRule: () => true
                    },
                    '../exception': {
                        report: function () {}
                    },
                    '../instrumentation/sqreenDirector': {
                        update: function () {

                            throw new Error();
                        }
                    }
                });

                MockedRules.enforceRuleList([
                    {
                        hookpoint: {
                            klass: 'module#version:file',
                            method: 'method',
                            callback_class: 'HeadersInsertCB'
                        }
                    }
                ]);
                done();
            });
        });
    });
});
