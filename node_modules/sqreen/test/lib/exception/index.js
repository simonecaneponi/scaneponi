/**
 * Copyright (c) 2016 Sqreen. All Rights Reserved.
 * Please refer to our terms for more information: https://www.sqreen.io/terms.html
 */
'use strict';
const Code = require('code');
const Lab = require('lab');
const lab = exports.lab = Lab.script();

const describe = lab.describe;
const it = lab.it;
const expect = Code.expect;

const Proxyquire = require('proxyquire');
const Exception = require('../../../lib/exception/index');
const Util = require('util');


describe('Exc', () => {

    describe('report', () => {

        it('should report an error to the event queue', { plan: 7 }, (done) => {

            const MockedException = Proxyquire('../../../lib/exception/index', {
                '../events': {
                    writeEvent: function (type, payload) {

                        expect(type).to.equal('ERROR');
                        expect(payload).to.exist();
                        expect(payload.message).to.equal('my error');
                        expect(payload.context.backtrace).to.exist();
                        expect(payload.context.backtrace).to.be.an.array();
                        expect(payload.context.backtrace.length).to.be.at.least(4);
                        return Promise.resolve();
                    }
                }
            });

            const err = new Error('my error');
            err.ruleName = 'poney';
            err.rulesPack = 'dgf57d3f5sh74';
            MockedException.report(err)
                .catch((err) => {

                    expect(err.reported).to.be.true();
                    done();
                });
        });

        it('should report a non error to the event queue', { plan: 8 }, (done) => {

            const MockedException = Proxyquire('../../../lib/exception/index', {
                '../events': {
                    writeEvent: function (type, payload) {

                        expect(type).to.equal('ERROR');
                        expect(payload).to.exist();
                        expect(payload.message).to.equal(Util.inspect('my error'));
                        expect(payload.context.backtrace).to.exist();
                        expect(payload.context.backtrace).to.be.an.array();
                        expect(payload.context.backtrace.length).to.be.at.least(3);
                        return Promise.resolve();
                    }
                }
            });

            MockedException.report('my error')
                .catch((err) => {

                    expect(err.reported).to.be.true();
                    expect(err).to.be.an.instanceof(Error);
                    done();
                });
        });

        it('should report a non error to the event queue', { plan: 8 }, (done) => {

            const MockedException = Proxyquire('../../../lib/exception/index', {
                '../events': {
                    writeEvent: function (type, payload) {

                        expect(type).to.equal('ERROR');
                        expect(payload).to.exist();
                        expect(payload.message).to.equal(Util.inspect({}));
                        expect(payload.context.backtrace).to.exist();
                        expect(payload.context.backtrace).to.be.an.array();
                        expect(payload.context.backtrace.length).to.be.at.least(3);
                        return Promise.resolve();
                    }
                }
            });

            MockedException.report({})
                .catch((err) => {

                    expect(err.reported).to.be.true();
                    expect(err).to.be.an.instanceof(Error);
                    done();
                });
        });

        it('should report a non error to the event queue', { plan: 8 }, (done) => {

            const MockedException = Proxyquire('../../../lib/exception/index', {
                '../events': {
                    writeEvent: function (type, payload) {

                        expect(type).to.equal('ERROR');
                        expect(payload).to.exist();
                        expect(payload.message).to.equal(Util.inspect(''));
                        expect(payload.context.backtrace).to.exist();
                        expect(payload.context.backtrace).to.be.an.array();
                        expect(payload.context.backtrace.length).to.be.at.least(3);
                        return Promise.resolve();
                    }
                }
            });

            MockedException.report(null)
                .catch((err) => {

                    expect(err.reported).to.be.true();
                    expect(err).to.be.an.instanceof(Error);
                    done();
                });
        });

        it('should not report an error that has already been reported', { plan: 1 }, (done) => {

            const error = new Error('my error');
            error.reported = true;
            Exception.report(error)
                .catch((err) => {

                    expect(err.reported).to.be.true();
                    done();
                });
        });
    });
});


