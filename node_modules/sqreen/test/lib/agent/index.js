/**
 * Copyright (c) 2016 Sqreen. All Rights Reserved.
 * Please refer to our terms for more information: https://www.sqreen.io/terms.html
 */
'use strict';
const Code = require('code');
const Lab = require('lab');
const lab = exports.lab = Lab.script();

const describe = lab.describe;
const it = lab.it;
const expect = Code.expect;

const Agent = require('../../../lib/agent/index');
const Proxyquire = require('proxyquire');

describe('Agent', () => {

    describe('STARTED', () => {

        it('should return false', { plan: 2 }, (done) => {

            const started = Agent.STARTED();
            expect(started).to.be.a.boolean();
            expect(started).to.be.false();
            done();
        });
    });

    describe('SESSION_ID', () => {

        it('should return undefined', { plan: 1 }, (done) => {

            const started = Agent.SESSION_ID();
            expect(started).to.not.exist();
            done();
        });
    });

    describe('heartBeatWorker', () => {

        it('should send a heartbeat and get an empty command list', { plan: 1 }, (done) => {

            const MockedAgent = Proxyquire('../../../lib/agent/index', {
                '../backend': {
                    heartBeat: function (session) {

                        expect(session).to.not.exist();
                        return Promise.resolve({ commands: [] });
                    }
                }
            });

            MockedAgent._heartBeatWorker()
                .then(() => {

                    done();
                });
        });

        it('should send a heartbeat and get a command list', { plan: 2 }, (done) => {

            const MockedAgent = Proxyquire('../../../lib/agent/index', {
                '../backend': {
                    heartBeat: function (session) {

                        expect(session).to.not.exist();
                        return Promise.resolve({ commands: [{ name: 'mock' }] });
                    }
                },
                '../command': {
                    execute: function (command) {

                        expect(command.name).to.equal('mock');
                        return Promise.resolve();
                    }
                }
            });

            MockedAgent._heartBeatWorker()
                .then(() => {

                    done();
                });
        });

        it('should send a heartbeat and get a command list then execute a failed command', { plan: 3 }, (done) => {

            const MockedAgent = Proxyquire('../../../lib/agent/index', {
                '../backend': {
                    heartBeat: function (session) {

                        expect(session).to.not.exist();
                        return Promise.resolve({ commands: [{ name: 'mock' }] });
                    }
                },
                '../command': {
                    execute: function (command) {

                        expect(command.name).to.equal('mock');
                        return Promise.reject('my err');
                    }
                },
                '../exception': {
                    report: function (err) {

                        expect(err).to.equal('my err');
                        done();
                        return Promise.reject();
                    }
                }
            });

            MockedAgent._heartBeatWorker();
        });

        it('should fail at sending a heartbeat', { plan: 2 }, (done) => {

            const ERR = new Error('mock');
            const MockedAgent = Proxyquire('../../../lib/agent/index', {
                '../backend': {
                    heartBeat: function (session) {

                        expect(session).to.not.exist();
                        return Promise.reject(ERR);
                    }
                },
                '../exception': {
                    report: function (err) {

                        expect(err).to.equal(ERR);
                        done();
                        return Promise.reject();
                    }
                }
            });

            MockedAgent._heartBeatWorker();
        });

    });

    describe('heartBeatLoopStarter', () => {

        it('should set-up an interval', { plan: 3 }, (done) => {

            let counter = 0;
            const MockedAgent = Proxyquire('../../../lib/agent/index', {
                '../backend': {
                    heartBeat: function () {

                        counter++;
                        return Promise.resolve({ commands: [] });
                    }
                }
            });

            const interval = MockedAgent._startHeartBeatLoop(100);
            expect(interval).to.exist();


            setTimeout(() => {

                expect(counter).to.be.above(8);
                expect(counter).to.be.below(12);
                clearInterval(interval);
                done();
            }, 1000);
        });
    });

    describe('heartBeatLoopStarter', () => {

        it('should start the heartbeat loop and change timming after a while', { plan: 2 }, (done) => {

            let counter = 0;
            const MockedAgent = Proxyquire('../../../lib/agent/index', {
                '../backend': {
                    heartBeat: function () {

                        counter++;
                        return Promise.resolve({ commands: [] });
                    }
                }
            });

            MockedAgent.heartBeatLoopStarter({ firstInterval: 50, secondInterval: 120, changeIntervalAfter: 100 });

            setTimeout(() => {

                expect(counter).to.be.at.least(2);
                expect(counter).to.be.below(4);
                MockedAgent._clearAll();
                done();
            }, 250);

        });

        it('should start the heartbeat loop', { plan: 2 }, (done) => {

            let counter = 0;
            const MockedAgent = Proxyquire('../../../lib/agent/index', {
                '../backend': {
                    heartBeat: function () {

                        counter++;
                        return Promise.resolve({ commands: [] });
                    }
                }
            });

            MockedAgent.heartBeatLoopStarter({ firstInterval: 50 });

            setTimeout(() => {

                expect(counter).to.be.at.least(4);
                expect(counter).to.be.below(6);
                MockedAgent._clearAll();
                done();
            }, 250);

        });
    });

    describe('start', () => {

        it('should start the agent without error', { plan: 3 }, (done) => {

            const MockedAgent = Proxyquire('../../../lib/agent/index', {
                '../backend': {
                    heartBeat: function () {

                        return Promise.resolve({ commands: [] });
                    },
                    login: function (token) {

                        expect(token).to.equal('token');
                        return Promise.resolve('session');
                    }
                }
            });

            MockedAgent.start({ token: 'token' })
                .then(() => {

                    expect(MockedAgent.STARTED()).to.be.true();
                    expect(MockedAgent.SESSION_ID()).to.be.equal('session');
                    MockedAgent._clearAll();
                    done();
                });
        });

        it('should start the agent without error with default values', { plan: 3 }, (done) => {

            const MockedAgent = Proxyquire('../../../lib/agent/index', {
                '../backend': {
                    heartBeat: function () {

                        return Promise.resolve({ commands: [] });
                    },
                    login: function (token) {

                        expect(token).to.equal('token');
                        return Promise.resolve('session');
                    }
                },
                '../command/features': {
                    read: function () {

                        return {
                            heartbeat_delay: 10
                        };
                    }
                }
            });

            MockedAgent.start({ token: 'token' })
                .then(() => {

                    expect(MockedAgent.STARTED()).to.be.true();
                    expect(MockedAgent.SESSION_ID()).to.be.equal('session');
                    MockedAgent._clearAll();
                    done();
                });
        });

        it('should fail to start the agent', { plan: 3 }, (done) => {

            const MockedAgent = Proxyquire('../../../lib/agent/index', {
                '../backend': {
                    heartBeat: function () {

                        return Promise.resolve({ commands: [] });
                    },
                    login: function (token) {

                        expect(token).to.equal('token');
                        return Promise.reject();
                    }
                }
            });

            MockedAgent.start({ token: 'token' })
                .catch(() => {

                    expect(MockedAgent.STARTED()).to.be.false();
                    expect(MockedAgent.SESSION_ID()).to.not.exist('session');
                    MockedAgent._clearAll();
                    done();
                });
        });
    });

    describe('stop', () => {

        it('should stop the agent', { plan: 6 }, (done) => {

            const MockedAgent = Proxyquire('../../../lib/agent/index', {
                '../backend': {
                    heartBeat: function () {

                        return Promise.resolve({ commands: [] });
                    },
                    login: function (token) {

                        expect(token).to.equal('token');
                        return Promise.resolve('session');
                    },
                    logout: function (session) {

                        expect(session).to.equal('session');
                        return Promise.resolve();
                    }
                }
            });

            MockedAgent.start({ token: 'token' })
                .then(() => {

                    expect(MockedAgent.STARTED()).to.be.true();
                    expect(MockedAgent.SESSION_ID()).to.be.equal('session');
                })
                .then(() => MockedAgent.stop('session'))
                .then(() => {

                    expect(MockedAgent.STARTED()).to.be.false();
                    expect(MockedAgent.SESSION_ID()).to.not.exist();
                    done();
                });
        });

        it('should stop the agent', { plan: 6 }, (done) => {

            const MockedAgent = Proxyquire('../../../lib/agent/index', {
                '../backend': {
                    heartBeat: function () {

                        return Promise.resolve({ commands: [] });
                    },
                    login: function (token) {

                        expect(token).to.equal('token');
                        return Promise.resolve('session');
                    },
                    logout: function (session) {

                        expect(session).to.equal('session');
                        return Promise.reject();
                    }
                }
            });

            MockedAgent.start({ token: 'token' })
                .then(() => {

                    expect(MockedAgent.STARTED()).to.be.true();
                    expect(MockedAgent.SESSION_ID()).to.be.equal('session');
                })
                .then(() => MockedAgent.stop('session'))
                .then(() => {

                    expect(MockedAgent.STARTED()).to.be.true();
                    expect(MockedAgent.SESSION_ID()).to.exist();
                    done();
                });
        });

        it('should try to stop the agent that is already stopped', { plan: 2 }, (done) => {

            const MockedAgent = Proxyquire('../../../lib/agent/index', {
                '../backend': {
                    logout: function () {

                        done(new Error('this should not have been called'));
                    }
                }
            });

            MockedAgent.stop('session')
                .then(() => {

                    expect(MockedAgent.STARTED()).to.be.false();
                    expect(MockedAgent.SESSION_ID()).to.not.exist();
                    done();
                });
        });

        it('should stop the agent', { plan: 6 }, (done) => {

            const env = process.env.NODE_ENV;

            const MockedAgent = Proxyquire('../../../lib/agent/index', {
                '../backend': {
                    heartBeat: function () {

                        return Promise.resolve({ commands: [] });
                    },
                    login: function (token) {

                        expect(token).to.equal('token');
                        return Promise.resolve('session');
                    },
                    logout: function (session) {

                        expect(session).to.equal('session');
                        return Promise.resolve();
                    }
                }
            });

            MockedAgent.start({ token: 'token' })
                .then(() => {

                    expect(MockedAgent.STARTED()).to.be.true();
                    expect(MockedAgent.SESSION_ID()).to.be.equal('session');
                    delete process.env.NODE_ENV;
                })
                .then(() => MockedAgent.stop('session'))
                .then(() => {

                    expect(MockedAgent.STARTED()).to.be.false();
                    expect(MockedAgent.SESSION_ID()).to.not.exist();
                    process.env.NODE_ENV = env;
                    done();
                });
        });


        it('should try to stop the agent that is in dev', { plan: 2 }, (done) => {

            const env = process.env.NODE_ENV;
            process.env.NODE_ENV = 'dev';

            const MockedAgent = Proxyquire('../../../lib/agent/index', {
                '../backend': {
                    logout: function () {

                        done(new Error('this should not have been called'));
                    }
                }
            });

            MockedAgent.stop('session')
                .then(() => {

                    expect(MockedAgent.STARTED()).to.be.false();
                    expect(MockedAgent.SESSION_ID()).to.not.exist();
                    process.env.NODE_ENV = env;
                    done();
                });
        });
    });
});
