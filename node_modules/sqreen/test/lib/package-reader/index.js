/**
 * Copyright (c) 2016 Sqreen. All Rights Reserved.
 * Please refer to our terms for more information: https://www.sqreen.io/terms.html
 */
'use strict';
const Code = require('code');
const Lab = require('lab');
const lab = exports.lab = Lab.script();

const describe = lab.describe;
const it = lab.it;
const expect = Code.expect;

const Fs = require('fs');
const Path = require('path');

const Rimraf = require('rimraf');

const Reader = require('../../../lib/package-reader');

describe('package-reader', () => {

    describe('getDependenciesHash', () => {

        it('should return the hash of sqreen agent deps', { plan: 1 }, (done) => {

            Reader.getDependenciesHash((res) => {

                expect(res).to.have.length(40);
                done();
            });
        });

        it('should return the hash of sqreen agent deps with a readFile error', { plan: 1 }, (done) => {

            const readFile = Fs.readFile;

            Fs.readFile = function (x, y, cb) {

                Fs.readFile = readFile;
                return cb(new Error('I am an error'));
            };

            Reader.getDependenciesHash((res) => {

                expect(res).to.have.length(40);
                done();
            });
        });

        it('should return the hash of sqreen agent deps even is a file is malformed', { plan: 1 }, (done) => {

            Fs.writeFileSync(process.cwd() + '/node_modules/hoek/my_package.json', 'aaaaa');
            Reader.getDependenciesHash((res) => {

                expect(res).to.have.length(40);
                Fs.unlinkSync(process.cwd() + '/node_modules/hoek/my_package.json');
                done();
            });
        });

    });

    describe('readPackage', () => {

        it('should smoothly read the content of a json file', { plan: 2 }, (done) => {

            const json = { hello: 'world' };
            Fs.writeFileSync('./tmp.json', JSON.stringify(json));

            const result = Reader.readPackage(Path.join(process.cwd(),'tmp.json'));

            expect(result).to.exist();
            expect(result.hello).to.equal('world');

            Fs.unlinkSync('./tmp.json');
            done();
        });

        it('should smoothly read the content of a json file when deps', { plan: 2 }, (done) => {

            const json = { hello: 'world', dependencies: { 'a.1': 1 } };
            Fs.writeFileSync('./tmp.json', JSON.stringify(json));

            const result = Reader.readPackage(Path.join(process.cwd(),'tmp.json'));

            expect(result).to.exist();
            expect(result.hello).to.equal('world');

            Fs.unlinkSync('./tmp.json');
            done();
        });

        it('should smoothly read the content of a json file when devDeps', { plan: 2 }, (done) => {

            const json = { hello: 'world', devDependencies: { 'a.1': 1 } };
            Fs.writeFileSync('./tmp.json', JSON.stringify(json));

            const result = Reader.readPackage(Path.join(process.cwd(),'tmp.json'));

            expect(result).to.exist();
            expect(result.hello).to.equal('world');

            Fs.unlinkSync('./tmp.json');
            done();
        });

        it('should not read the content of a malformed json file', { plan: 1 }, (done) => {

            Fs.writeFileSync('./tmp.json', '{');

            const result = Reader.readPackage(Path.join(process.cwd(),'tmp.json'));

            expect(result).to.not.exist();

            Fs.unlinkSync('./tmp.json');
            done();
        });

        it('should not read the content of a non existing file', { plan: 1 }, (done) => {

            const result = Reader.readPackage(Path.join(process.cwd(),'tmp.json'));

            expect(result).to.not.exist();

            done();
        });
    });

    describe('listModules', () => {

        it('should return a rejected promise when the directory does not exist', { plan: 1 }, (done) => {

            Reader.listModules('./my_node_modules')
                .then(() => done(new Error('this should have failed')))
                .catch((err) => {

                    expect(err).to.exist();
                    done();
                });
        });

        it('should return a fulfiled promise with the path to the package.json files', { plan: 3 }, () => {

            Fs.mkdirSync('./my_node_modules');
            Fs.mkdirSync('./my_node_modules/mod1');
            Fs.mkdirSync('./my_node_modules/mod1/node_modules');
            const CP = require('child_process');
            CP.execSync('ln -s ./my_node_modules/mod1 ./my_node_modules/mod1/node_modules/mod1');
            Fs.writeFileSync('./my_node_modules/mod1/package.json', JSON.stringify({ name: 'sqreen' }));
            Fs.writeFileSync('./my_node_modules/fakePackage.json', JSON.stringify({ name: 'sqreen' }));

            return Reader.listModules('./my_node_modules')
                .then((list) => {

                    expect(list).to.exist();
                    expect(list).to.be.an.array();
                    expect(list).to.have.length(1);
                })
                .then(() => {

                    return new Promise((resolve) => {

                        Rimraf('./my_node_modules', () => {

                            return resolve();
                        });
                    });
                });
        });
    });

    describe('getDependencies', () => {

        it('should list the dependencies of sqreen', { plan: 3 }, () => {

            return Reader.getDependencies()
                .then((list) => {

                    expect(list).to.exist();
                    expect(list).to.be.an.array();
                    expect(list.length).to.be.above(200);
                });
        });

        it('should reject and not list the dependencies if \'node_modules\' does not exist', { plan: 1 }, (done) => {

            const baseDir = process.cwd();
            process.chdir('./test');

            Reader.getDependencies()
                .then(() => done(new Error('this should have failed')))
                .catch((x) => {

                    expect(x).to.exist();
                    process.chdir(baseDir);
                    done();
                });
        });
    });

});

