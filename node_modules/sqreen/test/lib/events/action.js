/**
 * Copyright (c) 2016 Sqreen. All Rights Reserved.
 * Please refer to our terms for more information: https://www.sqreen.io/terms.html
 */
'use strict';
const Code = require('code');
const Lab = require('lab');
const lab = exports.lab = Lab.script();

const describe = lab.describe;
const it = lab.it;
const expect = Code.expect;

const Proxyquire = require('proxyquire');

const Action = require('../../../lib/events/action');

describe('Event.action', () => {

    describe('batch', () => {

        it('should enable and disable batch mode', { plan: 0 }, (done) => {

            Action.disableBatch();
            Action.enableBatch({ max_staleness: 50000 });
            done();
        });

        describe('reportBatch', () => {

            it('should report a queue', { plan: 3 }, (done) => {

                const MockedAction = Proxyquire('../../../lib/events/action', {
                    '../agent': {
                        SESSION_ID: function () {

                            return 'session';
                        }
                    },
                    '../backend': {
                        batch: function (token, batch) {

                            expect(token).to.equal('session');
                            expect(batch).to.exist();
                            return Promise.resolve();
                        }
                    }
                });

                const queue = [{ type: 'attack',  event: { a: 1 } }];
                MockedAction.reportBatch(queue);
                expect(queue).to.have.length(0);
                done();
            });

            it('should fail to report a queue', { plan: 4 }, () => {

                const MockedAction = Proxyquire('../../../lib/events/action', {
                    '../agent': {
                        SESSION_ID: function () {

                            return 'session';
                        }
                    },
                    '../backend': {
                        batch: function (token, batch) {

                            expect(token).to.equal('session');
                            expect(batch[0]).to.equal({ a: 1, event_type: 'attack' });
                            return Promise.reject();
                        }
                    }
                });

                const queue = [{ type: 'attack',  event: { a: 1 } }];
                return MockedAction.reportBatch(queue)
                    .then(() => {

                        expect(queue).to.have.length(1);
                        expect(queue[0]).to.equal({ type: 'attack',  event: { a: 1, event_type: 'attack' } });
                        return Promise.resolve();
                    });
            });

            it('should fail to report a queue and drop some messages', { plan: 3 }, () => {

                const MockedAction = Proxyquire('../../../lib/events/action', {
                    '../agent': {
                        SESSION_ID: function () {

                            return 'session';
                        }
                    },
                    '../backend': {
                        batch: function (token, batch) {

                            expect(token).to.equal('session');
                            expect(batch[0]).to.equal({ a: 1, event_type: 'attack' });
                            return Promise.reject();
                        }
                    }
                });

                const queue = [];
                for (let i = 0; i < 10000; ++i) {
                    queue.push({ type: 'attack',  event: { a: 1 } });
                }
                return MockedAction.reportBatch(queue)
                    .then(() => {

                        expect(queue).to.have.length(501);
                        return Promise.resolve();
                    });
            });
        });

        describe('_batch', () => {

            it('should report since the batch is full', { plan: 2 }, (done) => {

                const MockedAction = Proxyquire('../../../lib/events/action', {
                    '../agent': {
                        SESSION_ID: function () {

                            return 'session';
                        },
                        STARTED: function () {

                            return true;
                        }
                    },
                    '../backend': {
                        batch: function () {

                            return Promise.resolve();
                        }
                    }
                });

                MockedAction.enableBatch({ batch_size: 2, max_staleness: 500000 });
                expect(MockedAction._batch([{},{},{}])).to.be.true();
                expect(MockedAction._batch([{},{},{}])).to.be.true();
                done();
            });

            it('should report since the batch is full but no, agent is offline', { plan: 1 }, (done) => {

                const MockedAction = Proxyquire('../../../lib/events/action', {
                    '../agent': {
                        SESSION_ID: function () {

                            return '';
                        },
                        STARTED: function () {

                            return true;
                        }
                    },
                    '../backend': {
                        batch: function () {

                            return Promise.resolve();
                        }
                    }
                });

                MockedAction.enableBatch({ batch_size: 2, max_staleness: 500000 });
                expect(MockedAction._batch([{},{},{}])).to.be.false();
                done();
            });

            it('should report since the time is over', { plan: 2 }, (done) => {

                const MockedAction = Proxyquire('../../../lib/events/action', {
                    '../agent': {
                        SESSION_ID: function () {

                            return 'session';
                        },
                        STARTED: function () {

                            return true;
                        }
                    },
                    '../backend': {
                        batch: function (key, payload) {

                            expect(payload).to.have.length(1);
                            done();
                            return Promise.resolve();
                        }
                    }
                });

                MockedAction.enableBatch({ batch_size: 10, max_staleness: 1000 });
                expect(MockedAction._batch([{}])).to.be.false();
            });

            it('should report since the time is over', { plan: 2 }, (done) => {

                const MockedAction = Proxyquire('../../../lib/events/action', {
                    '../agent': {
                        SESSION_ID: function () {

                            return 'session';
                        },
                        STARTED: function () {

                            return true;
                        }
                    },
                    '../backend': {
                        batch: function (key, payload) {

                            expect(payload).to.have.length(1);
                            done();
                            return Promise.resolve();
                        }
                    }
                });

                MockedAction.enableBatch({ batch_size: 10, max_staleness: 1000 });
                expect(MockedAction._batch([{}])).to.be.false();
            });

            it('should report with force the time is over', { plan: 1 }, (done) => {

                const MockedAction = Proxyquire('../../../lib/events/action', {
                    '../agent': {
                        SESSION_ID: function () {

                            return 'session';
                        },
                        STARTED: function () {

                            return true;
                        }
                    },
                    '../backend': {
                        batch: function (key, payload) {

                            expect(payload).to.have.length(1);
                            done();
                            return Promise.resolve();
                        }
                    }
                });

                MockedAction.enableBatch({ batch_size: 10, max_staleness: 10000 });
                MockedAction._batch([{}], true);
            });
        });

    });

    describe('reportEvent', () => {

        it('should do nothing when the event does not exists', { plan: 1 }, () => {

            return Action._reportEvent()
                .then((res) => {

                    expect(res).to.not.exist();
                });
        });

        it('should do nothing when the event type does not exists', { plan: 1 }, () => {

            return Action._reportEvent({ type: 'XXX' })
                .then((res) => {

                    expect(res).to.not.exist();
                });
        });

        it('should report an attack', { plan: 2 }, () => {

            const MockedAction = Proxyquire('../../../lib/events/action', {
                '../agent': {
                    SESSION_ID: function () {

                        return 'session';
                    }
                },
                '../backend': {
                    attack: function (token, atk) {

                        expect(token).to.equal('session');
                        expect(atk).to.exist();
                        return Promise.resolve();
                    }
                }
            });

            return MockedAction._reportEvent({ type: 'ATTACK', event: {} });
        });

        it('should report an exception', { plan: 2 }, () => {

            const MockedAction = Proxyquire('../../../lib/events/action', {
                '../agent': {
                    SESSION_ID: function () {

                        return 'session';
                    }
                },
                '../backend': {
                    exception: function (token, atk) {

                        expect(token).to.equal('session');
                        expect(atk).to.exist();
                        return Promise.resolve();
                    }
                }
            });

            return MockedAction._reportEvent({ type: 'ERROR', event: {} });
        });
    });

    describe('trigger', () => {

        it('should not do anything since the queue is empty', { plan: 1 }, () => {

            return Action.trigger()
                .then((res) => {

                    expect(res).to.not.exist();
                });
        });

        it('should not do anything since the agent is not connected', { plan: 1 }, () => {

            return Action.trigger([])
                .then((res) => {

                    expect(res).to.not.exist();
                });
        });

        it('should not do anything since the agent is connected without session id', { plan: 1 }, () => {

            const MockedAction = Proxyquire('../../../lib/events/action', {
                '../agent': {
                    STARTED: function () {

                        return true;
                    },
                    SESSION_ID: function () {

                        return;
                    }
                }
            });

            return MockedAction.trigger([])
                .then((res) => {

                    expect(res).to.not.exist();
                });
        });

        it('should should put back an event that could not be reported', { plan: 1, timeout: 35000 }, () => {

            const MockedAction = Proxyquire('../../../lib/events/action', {
                '../agent': {
                    STARTED: function () {

                        return true;
                    },
                    SESSION_ID: function () {

                        return 'session';
                    }
                },
                '../backend': {
                    exception: function () {

                        return Promise.reject();
                    }
                }
            });

            const queue = [{ type: 'ERROR', event: {} }];
            return MockedAction.trigger(queue)
                .then(() => {

                    expect(queue).to.have.length(1);
                });
        });

        it('should not do anything since the agent is in batch mode', { plan: 1 }, () => {

            const MockedAction = Proxyquire('../../../lib/events/action', {
                '../agent': {
                    STARTED: function () {

                        return true;
                    },
                    SESSION_ID: function () {

                        return 'session';
                    }
                }
            });
            MockedAction.enableBatch({});

            return MockedAction.trigger([{}])
                .then((res) => {

                    expect(res).to.not.exist();
                });
        });

        it('should not do anything since the event queue is empty', { plan: 1 }, () => {

            const MockedAction = Proxyquire('../../../lib/events/action', {
                '../agent': {
                    STARTED: function () {

                        return true;
                    },
                    SESSION_ID: function () {

                        return 'session';
                    }
                }
            });
            MockedAction.enableBatch({});

            return MockedAction.trigger([])
                .then((res) => {

                    expect(res).to.not.exist();
                });
        });

        it('should not do anything since the agent is not started', { plan: 1 }, () => {

            const MockedAction = Proxyquire('../../../lib/events/action', {
                '../agent': {
                    STARTED: function () {

                        return false;
                    },
                    SESSION_ID: function () {

                        return 'session';
                    }
                }
            });
            MockedAction.enableBatch({});

            return MockedAction.trigger([])
                .then((res) => {

                    expect(res).to.not.exist();
                });
        });

        it('should report an attack smoothly', { plan: 2 }, () => {

            const MockedAction = Proxyquire('../../../lib/events/action', {
                '../agent': {
                    STARTED: function () {

                        return true;
                    },
                    SESSION_ID: function () {

                        return 'session';
                    }
                },
                '../backend': {
                    attack: function (token, atk) {

                        expect(token).to.equal('session');
                        expect(atk).to.exist();
                        return Promise.resolve();
                    }
                }
            });

            return MockedAction.trigger([{ type: 'ATTACK', event: {} }]);
        });

    });
});
