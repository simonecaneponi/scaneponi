/**
 * Copyright (c) 2016 Sqreen. All Rights Reserved.
 * Please refer to our terms for more information: https://www.sqreen.io/terms.html
 */
'use strict';
const Code = require('code');
const Lab = require('lab');
const lab = exports.lab = Lab.script();

const describe = lab.describe;
const it = lab.it;
const expect = Code.expect;

const Proxyquire = require('proxyquire');

describe('Patch', () => {

    describe('_report', () => {

        it('should not report an attack', { plan: 0 }, (done) => {

            const Report = require('../../../lib/instrumentation/patch')._report;
            Report();
            done();
        });

        it('should report an attack', { plan: 6 }, (done) => {

            const Report = Proxyquire('../../../lib/instrumentation/patch', {
                '../constructors/attack': function (pl) {

                    expect(pl.rule_name).to.equal('rule');
                    expect(pl.rulespack_id).to.equal('0');
                    expect(pl.infos).to.equal('infos');
                    expect(pl.request.scheme).to.equal('http');
                    expect(pl.client_ip).to.equal('168.0.0.1');
                    expect(pl.headers).to.equal([]);
                    done();
                }
            })._report;

            Report({
                rule: {
                    name: 'rule',
                    rulesPack: '0'
                },
                record: 'infos',
                params: 'params',
                session: {
                    req: {
                        req: 'req',
                        connection: {
                            remoteAddress: '168.0.0.1'
                        }
                    }
                }
            });
        });

        it('should report an attack', { plan: 3 }, (done) => {

            const Report = Proxyquire('../../../lib/instrumentation/patch', {
                '../constructors/attack': function (pl) {

                    expect(pl.rule_name).to.equal('rule');
                    expect(pl.rulespack_id).to.equal('0');
                    expect(pl.headers).to.not.exist();
                    done();
                }
            })._report;

            Report({
                rule: {
                    name: 'rule',
                    rulesPack: '0'
                },
                record: 'infos',
                params: 'params',
                session: {}
            });
        });

        it.skip('should report an attack in whitelisted path', { plan: 8 }, (done) => {

            const Report = Proxyquire('../../../lib/instrumentation/patch', {
                '../constructors/attack': function (pl) {

                    expect(pl.rule_name).to.equal('rule');
                    expect(pl.rulespack_id).to.equal('0');
                    expect(pl.infos).to.equal('infos');
                    // expect(pl.params.req).to.equal('req');
                    expect(pl.request.scheme).to.equal('http');
                    expect(pl.client_ip).to.equal('127.0.0.1');
                    expect(pl.block).to.equal(false);
                    expect(pl.whitelist_match).to.equal('/admin/');
                    expect(pl.headers).to.equal([]);
                    done();
                }
            })._report;

            Report({
                rule: {
                    name: 'rule',
                    rulesPack: '0'
                },
                record: 'infos',
                params: 'params',
                session: {
                    req: {
                        headers: {
                            'x-forwarded-for': '192.168.0.1',
                            host: 'localhost:3000'
                        },
                        req: 'req',
                        connection: {
                            remoteAddress: '127.0.0.1'
                        },
                        rawHeaders: []
                    }
                }
            }, null, '/admin/');
        });

        it('should report an attack', { plan: 5 }, (done) => {

            const Report = Proxyquire('../../../lib/instrumentation/patch', {
                '../constructors/attack': function (pl) {

                    expect(pl.rule_name).to.equal('rule');
                    expect(pl.rulespack_id).to.equal('0');
                    expect(pl.infos).to.equal('infos');
                    // expect(pl.params.req).to.equal('req');
                    expect(pl.request.scheme).to.equal('http');
                    expect(pl.client_ip).to.equal('127.0.0.1');
                    done();
                }
            })._report;

            Report({
                rule: {
                    name: 'rule',
                    rulesPack: '0'
                },
                record: 'infos',
                params: 'params',
                session: {
                    req: {
                        req: 'req',
                        connection: {
                            remoteAddress: '127.0.0.1'
                        }
                    }
                }
            });
        });

        it('should report an attack', { plan: 1 }, (done) => {

            const Report = Proxyquire('../../../lib/instrumentation/patch', {
                '../constructors/attack': function (pl) {

                    expect(pl).to.exist();
                    done();
                }
            })._report;

            Report({
                rule: {}
            });
        });
        it('should report an attack', { plan: 1 }, (done) => {

            const Report = Proxyquire('../../../lib/instrumentation/patch', {
                '../constructors/attack': function (pl) {

                    expect(pl).to.exist();
                    done();
                }
            })._report;

            Report({
                rule: {},
                session: {}
            });
        });
        it('should report an attack', { plan: 1 }, (done) => {

            const Report = Proxyquire('../../../lib/instrumentation/patch', {
                '../constructors/attack': function (pl) {

                    expect(pl).to.exist();
                    done();
                }
            })._report;

            Report({
                rule: {},
                session: {
                    req: {
                        headers: {},
                        connection: {},
                        rawHeaders: [
                            'x-forwarded-for', 'a',
                            'x-cluster-client-ip', 'b'
                        ]
                    }
                }
            });
        });
    });

    describe('_actOnCbResult', () => {

        it('should not not do anything if the list is empty', { plan: 1 }, (done) => {

            const Patch = require('../../../lib/instrumentation/patch');

            const res = Patch._actOnCbResult([]);
            expect(res).to.not.exist();
            done();
        });

        it('should not skip even if the rule is in test because of SQREEN_BLOCK_ALL', { plan: 1 }, (done) => {

            const Patch = Proxyquire('../../../lib/instrumentation/patch', {
                '../config': {
                    getConfig: function () {

                        return {
                            block_all_rules: true
                        };
                    }
                }
            });

            const res = Patch._actOnCbResult([{ status: 'skip', rule: { test: true } }], { req: { __sqreen_url: '/' } });
            expect(res.status).to.equal('skip');
            done();
        });

    });

    describe('removeAllCallbacks', () => {

        it('should remove all callbacks from patches', { plan: 4 }, (done) => {

            const Patch = Proxyquire('../../../lib/instrumentation/patch', {
                './sqreenDirector': {
                    register: function () { }
                }
            });

            const p1 = new Patch({ a: function (){} }, 'a');
            p1.hasCbs = true;
            p1.preCbs.push({ x: 1 });

            expect(p1.hasCbs).to.be.true();
            expect(p1.preCbs).to.have.length(1);
            Patch.removeAllCallbacks();
            expect(p1.hasCbs).to.be.false();
            expect(p1.preCbs).to.have.length(0);
            done();
        });
    });

    describe('_logExec', () => {

        it('should collect call count', { plan: 1 }, (done) => {

            const Patch = Proxyquire('../../../lib/instrumentation/patch', {
                '../metric': {
                    addObservations: function (arr) {

                        expect(arr[0]).to.equal(['sqreen_call_counts', '1/name/pre', 3]);
                        done();
                    }
                },
                '../command/features': {
                    read: function () {

                        return {
                            call_counts_metrics_period: true
                        };
                    }
                }
            });

            Patch._logExec([
                { rule: {} },
                {},
                { rule: { call_count_interval: 0 } },
                { rule: { call_count_interval: 3, rulesPack: '1', name: 'name' } },
                { rule: { call_count_interval: 3, rulesPack: '1', name: 'name' } },
                { rule: { call_count_interval: 3, rulesPack: '1', name: 'name' } }
            ], 'pre');

        });

        it('should not collect call count', { plan: 0 }, (done) => {

            const Patch = Proxyquire('../../../lib/instrumentation/patch', {
                '../metric': {
                    addObservations: function () {

                        done(new Error('should not have been called'));
                    }
                },
                '../command/features': {
                    read: function () {

                        return {
                            call_counts_metrics_period: false
                        };
                    }
                }
            });

            Patch._logExec([
                { rule: {} },
                {},
                { rule: { call_count_interval: 0 } },
                { rule: { call_count_interval: 3, pack_id: '1', name: 'name' } },
                { rule: { call_count_interval: 3, pack_id: '1', name: 'name' } },
                { rule: { call_count_interval: 3, pack_id: '1', name: 'name' } }
            ], 'pre');
            done();

        });
    });

    describe('instrumented', () => {

        const Patch = require('../../../lib/instrumentation/patch');

        it('should not construct with cb', { plan: 3 }, (done) => {

            const original = function () {

                return 1;
            };
            const patch = new Patch(original, {}, '', '');

            patch.hasCbs = true;

            const obj1 = { __sqreen_constructed: true };
            expect(patch.instrumented.apply(obj1)).to.equal(1);

            const obj2 = {};
            Object.setPrototypeOf(obj2, null);
            expect(patch.instrumented.apply(obj2)).to.equal(1);

            const obj3 = new patch.instrumented();
            expect(obj3.__sqreen_constructed).to.be.true();

            done();
        });

        it('should not construct with cb that return frozzen objects', { plan: 1 }, (done) => {

            const original = function () {

                this.x = 1;
                Object.freeze(this);
            };
            const patch = new Patch(original, {}, '', '');

            const obj = new patch.instrumented();

            expect(obj.__sqreen_constructed).to.not.exist();

            done();
        });

        it('should not change the prototype', { plan: 2 }, (done) => {

            const original = function () {

                return 1;
            };
            Object.setPrototypeOf(original, null);
            original.prototype = { a: 1 };
            const patch = new Patch(original, {}, '', '');

            expect(Object.getPrototypeOf(patch.instrumented)).to.equal(null);
            expect(patch.instrumented.prototype).to.equal({ a: 1 });

            done();
        });

        it('should have an error in call but not catch it', { plan: 1 }, (done) => {

            const original = function (x) {

                throw x;
            };
            const patch = new Patch(original, {}, '', '');
            patch.hasCbs = true;
            patch.preCbs = [{
                method: function (args) {

                    args[0] = 1;
                }
            }];

            try {
                patch.instrumented(0);
            }
            catch (e) {
                expect(e).to.equal(1);
                done();
            }
        });
    });
});
