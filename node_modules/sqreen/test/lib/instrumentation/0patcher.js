/**
 * Copyright (c) 2016 Sqreen. All Rights Reserved.
 * Please refer to our terms for more information: https://www.sqreen.io/terms.html
 */
'use strict';
// I know this is ugly but this file needs to run before the tests of director

const Code = require('code');
const Lab = require('lab');
const lab = exports.lab = Lab.script();

const describe = lab.describe;
const it = lab.it;
const expect = Code.expect;
const patcherPath = '../../../lib/instrumentation/patcher';
const Patcher = require(patcherPath);

describe('patcher', () => {

    describe('placePatch', () => {

        it('should not place a patch if the target does not exist', { plan: 3 }, (done) => {

            expect(Patcher.placePatch({ })).to.not.exist();
            expect(Patcher.placePatch({ moduleName: 'mod' })).to.not.exist();
            expect(Patcher.placePatch({ moduleName: 'mod', file: './index.js' })).to.not.exist();
            done();
        });

        it('should patch a known module and add a callback', { plan: 4 }, (done) => {

            const module = {
                a: function () {

                    return 1;
                }
            };

            const result1 = Patcher.patchModule(module, { name: 'module', relativePath: './index.js' }, 'mod');

            expect(result1.a.__wrapped).to.not.exist();
            expect(result1.a()).to.equal(1);

            const Director = require('../../../lib/instrumentation/sqreenDirector');
            Director.update({
                moduleName: 'module',
                file: './index.js',
                methodName: 'a',
                build: () => {},
                params: {
                    preCbs: [
                        {
                            method: function () {

                                return { status: 'skip', newReturnValue: 2 };
                            }
                        }
                    ]
                }
            });
            Patcher.placePatch({
                moduleName: 'module',
                file: './index.js',
                methodName: 'a'
            });
            Patcher.placePatch({
                moduleName: 'module',
                file: './index.js',
                methodName: 'a:b'
            });
            Patcher.placePatch({
                moduleName: 'module',
                file: './index.js',
                methodName: 'b'
            });
            expect(result1.a.__wrapped).to.be.true();
            expect(result1.a()).to.equal(2);
            done();
        });

        it('should patch a known module and add a callback and trigger coverage', { plan: 4 }, (done) => {

            const module = {
                a: function () {

                    return 1;
                }
            };

            Patcher.placePatch({
                moduleName: 'module',
                file: './index.js',
                methodName: 'a.prototype:b'
            });

            module.a.prototype = null;

            const result1 = Patcher.patchModule(module, { name: 'module', relativePath: './index.js' }, 'mod');

            expect(result1.a.__wrapped).to.not.exist();
            expect(result1.a()).to.equal(1);

            Patcher.placePatch({
                moduleName: 'module',
                file: './index.js',
                methodName: 'a.prototype:b'
            });

            const Director = require('../../../lib/instrumentation/sqreenDirector');
            Director.update({
                moduleName: 'module',
                file: './index.js',
                methodName: 'a',
                build: () => {},
                params: {
                    preCbs: [
                        {
                            method: function () {

                                return { status: 'skip', newReturnValue: 2 };
                            }
                        }
                    ]
                }
            });
            expect(result1.a.__wrapped).to.be.true();
            expect(result1.a()).to.equal(2);
            done();
        });

        it('should patch a known module and add a callback', { plan: 4 }, (done) => {

            const module = {
                s: {
                    a: function () {

                        return 1;
                    }
                }
            };

            const result1 = Patcher.patchModule(module, { name: 'module', relativePath: './index.js' }, 'mod');

            expect(result1.s.a.__wrapped).to.not.exist();
            expect(result1.s.a()).to.equal(1);

            const Director = require('../../../lib/instrumentation/sqreenDirector');
            Director.update({
                moduleName: 'module',
                file: './index.js',
                methodName: 's:a',
                build: () => {},
                params: {
                    preCbs: [
                        {
                            method: function () {

                                return { status: 'skip', newReturnValue: 2 };
                            }
                        }
                    ]
                }
            });
            expect(result1.s.a.__wrapped).to.be.true();
            expect(result1.s.a()).to.equal(2);
            done();
        });

        it('should patch a known module and add a callback', { plan: 4 }, (done) => {

            const module = {
                c: class {

                    constructor() {

                        this.x = 1;
                    }

                    a() {

                        return this.x;
                    }
                }
            };

            const result1 = Patcher.patchModule(module, { name: 'module' }, 'mod');

            const instance = new result1.c();
            expect(instance.a.__wrapped).to.not.exist();
            expect(instance.a()).to.equal(1);

            const Director = require('../../../lib/instrumentation/sqreenDirector');
            Director.update({
                moduleName: 'module',
                methodName: 'c.prototype:a',
                build: () => {},
                params: {
                    preCbs: [
                        {
                            method: function () {

                                return { status: 'skip', newReturnValue: 2 };
                            }
                        }
                    ]
                }
            });

            Patcher.placePatch({
                moduleName: 'module',
                file: './index.js',
                methodName: 'c.prototype:b'
            });
            expect(instance.a.__wrapped).to.be.true();
            expect(instance.a()).to.equal(2);
            done();
        });

        it('should patch a known module without method name and add a callback', { plan: 4 }, (done) => {

            const module = {
                '': function () {

                    return 1;
                }
            };

            const result1 = Patcher.patchModule(module, { name: 'module', relativePath: './index.js' }, 'mod');

            expect(result1[''].__wrapped).to.not.exist();
            expect(result1['']()).to.equal(1);

            const Director = require('../../../lib/instrumentation/sqreenDirector');
            Director.update({
                moduleName: 'module',
                file: './index.js',
                build: () => {},
                params: {
                    preCbs: [
                        {
                            method: function () {

                                return { status: 'skip', newReturnValue: 2 };
                            }
                        }
                    ]
                }
            });
            expect(result1[''].__wrapped).to.be.true();
            expect(result1['']()).to.equal(2);
            done();
        });
    });
});
