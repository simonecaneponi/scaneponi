/**
 * Copyright (c) 2016 Sqreen. All Rights Reserved.
 * Please refer to our terms for more information: https://www.sqreen.io/terms.html
 */
'use strict';
const Code = require('code');
const Lab = require('lab');
const lab = exports.lab = Lab.script();

const describe = lab.describe;
const it = lab.it;
const expect = Code.expect;
const afterEach = lab.afterEach;

const Proxyquire = require('proxyquire');
const Fs = require('fs');
const Module = require('module');
const load = Module._load;
const Decache = require('decache');

afterEach((done) => {

    Module._load = load;
    done();
});

describe('moduleHijacker', () => {

    describe('enable', () => {

        it('should catch the loading of a dependency', { plan: 2 }, (done) => {

            const MockedModuleHijacker = Proxyquire('../../../lib/instrumentation/moduleHijacker', {
                './moduleIdentity': {
                    scan: function () {

                        return {
                            core: false,
                            internal: false,
                            forceHj: true
                        };
                    }
                },
                './patcher': {
                    patchModule: function (loadedModule) {

                        expect(loadedModule).to.exist();
                        expect(loadedModule.timeout).to.exist();
                        done();
                    }
                }
            });

            MockedModuleHijacker.enable();
            Decache('./useless');
            require('./useless');
        });

        it('should catch the loading of a dependency but not instrument it', { plan: 0 }, (done) => {

            const MockedModuleHijacker = Proxyquire('../../../lib/instrumentation/moduleHijacker', {
                './patcher': {
                    patchModule: function () {

                        done(new Error('should not have been called'));
                    }
                }
            });

            MockedModuleHijacker.enable();
            require('tapable');
            done();
        });

        it('should catch the loading of a dependency and prove specific instrumentation', { plan: 1 }, (done) => {

            const MockedModuleHijacker = Proxyquire('../../../lib/instrumentation/moduleHijacker', {
                './moduleIdentity': {
                    scan: function () {

                        return {
                            core: false,
                            internal: false,
                            forceHj: true
                        };
                    }
                },
                './hooks': {
                    './useless': function (identity) {

                        expect(identity.core).to.be.false();
                        done();
                    }
                }
            });

            MockedModuleHijacker.enable();
            Decache('./useless');
            require('./useless');
        });


        it('should catch the loading of a dependency and prove specific instrumentation but throw and report', { plan: 1 }, (done) => {

            const MockedModuleHijacker = Proxyquire('../../../lib/instrumentation/moduleHijacker', {
                './moduleIdentity': {
                    scan: function () {

                        return {
                            core: false,
                            internal: false,
                            forceHj: true
                        };
                    }
                },
                './hooks': {
                    './useless': function () {

                        throw new Error('I am an error');
                    }
                },
                '../exception': {
                    report: function (err) {

                        expect(err.message).to.equal('I am an error - ./useless');
                        done();
                        return Promise.reject();
                    }
                }
            });

            MockedModuleHijacker.enable();
            Decache('./useless');
            require('./useless');
        });

        it('should handle thrown error in patcher', { plan: 2 }, (done) => {

            const MockedModuleHijacker = Proxyquire('../../../lib/instrumentation/moduleHijacker', {
                './moduleIdentity': {
                    scan: function () {

                        return {
                            core: false,
                            internal: false
                        };
                    }
                },
                './patcher': {
                    patchModule: function () {

                        expect(true).to.be.true(); // ensure call
                        throw new Error('my error');
                    }
                }
            });

            MockedModuleHijacker.enable();
            const res = require('util');
            expect(res.deprecate).to.exist();
            done();
        });

        it('should catch the loading of a dependency and cache it', { plan: 3 }, (done) => {

            const MockedModuleHijacker = Proxyquire('../../../lib/instrumentation/moduleHijacker', {
                './moduleIdentity': {
                    scan: function (request) {

                        return {
                            core: true,
                            internal: false,
                            name: request
                        };
                    }
                },
                './patcher': {
                    patchModule: function (loadedModule, identity) {

                        if (identity.name === 'http') {
                            expect(loadedModule).to.exist();
                        }
                        loadedModule.cached = true;
                        return loadedModule;
                    }
                }
            });

            MockedModuleHijacker.enable();
            require('http');
            const res = require('http');
            expect(res.Server).to.exist();
            expect(res.cached).to.be.true();
            done();
        });

        it('should catch the loading of a dependency and not cache it', { plan: 3 }, (done) => {

            const MockedModuleHijacker = Proxyquire('../../../lib/instrumentation/moduleHijacker', {
                './moduleIdentity': {
                    scan: function (request) {

                        return {
                            core: true,
                            internal: false,
                            name: request
                        };
                    }
                },
                './patcher': {
                    patchModule: function (loadedModule) {

                        expect(loadedModule).to.exist();
                        loadedModule.cached = true;
                        return loadedModule;
                    }
                }
            });

            MockedModuleHijacker.enable();
            Decache('./useless');
            require('./useless');
            const res = require('./useless');
            expect(res.value).to.exist();
            expect(res.value).to.equal(10);
            done();
        });
    });

    describe('enable and circular dependencies', () => {

        it('should catch the 2 modules loading', { plan: 5 }, (done) => {

            const MockedModuleHijacker = Proxyquire('../../../lib/instrumentation/moduleHijacker', {
                './moduleIdentity': {
                    scan: function () {

                        return {
                            core: false,
                            internal: false,
                            forceHj: true
                        };
                    }
                },
                './patcher': {
                    patchModule: function (loadedModule) {

                        expect(loadedModule).to.exist();
                        loadedModule.cached = true;
                        return loadedModule;
                    }
                }
            });

            MockedModuleHijacker.enable();

            const script1 = `
require('./script2');
module.exports.v1 = 1;
            `;

            const script2 = `
const v1 = require('./script1').v1;
module.exports.v2 = 2;
module.exports.v1 = v1;
            `;

            Fs.writeFileSync('./test/lib/instrumentation/script1.js', script1);
            Fs.writeFileSync('./test/lib/instrumentation/script2.js', script2);

            const s2 = require('./script2');

            expect(s2.v2).to.equal(2);
            expect(s2.v1).to.equal(1);

            const s1 = require('./script1');

            expect(s1.v1).to.equal(1);


            Fs.unlinkSync('./test/lib/instrumentation/script1.js');
            Fs.unlinkSync('./test/lib/instrumentation/script2.js');

            done();
        });
    });
});

const Path = require('path');
describe('Safety', () => {

    require('./useless');

    it('should ensure equality between public and private cache', { plan: 3 }, (done) => {

        const keys = Object.keys(Module._cache);
        const max = Math.min(1000000, keys.length);
        let idem = true;
        for (let i = 0; i < max; ++i) {
            idem = idem && (Module._cache[keys[i]] === require.cache[keys[i]]);
        }
        expect(idem).to.be.true();

        const useless = Path.join(Path.dirname(__filename), './useless.js');
        expect(Module._cache[useless]).to.exist();
        expect(Module._cache[useless].exports.value).to.equal(10);
        done();
    });
});
