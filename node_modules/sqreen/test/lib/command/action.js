/**
 * Copyright (c) 2016 Sqreen. All Rights Reserved.
 * Please refer to our terms for more information: https://www.sqreen.io/terms.html
 */
'use strict';
const Code = require('code');
const Lab = require('lab');
const lab = exports.lab = Lab.script();

const describe = lab.describe;
const it = lab.it;
const expect = Code.expect;

const Action = require('../../../lib/command/actions');
const Proxyquire = require('proxyquire');

describe('Command.action', () => {

    describe('instrumentation_enable', () => {

        it('should throw since agent is offline', { plan: 1 }, () => {

            require('../../../lib/agent').setSESSION_ID(undefined);

            return Action.instrumentation_enable()
                .catch((err) => {

                    expect(err.message).to.equal('agent is offline');
                });
        });

        it('should ask for a new rulespack but fail to verify them', { plan: 1 }, (done) => {

            const MockedAction = Proxyquire('../../../lib/command/actions', {
                '../agent': {
                    SESSION_ID: function () {

                        return 'id';
                    }
                },
                '../backend': {
                    rulespack: function () {

                        return Promise.resolve({ pack_id: 10, rules: [{ a: 1 }] });
                    }
                }
            });

            MockedAction.instrumentation_enable()
                .catch((err) => {

                    expect(err.message).to.equal('invalid rulespack: 10');
                    done();
                });
        });

        it('should ask for a new rulespack but get an empty one', { plan: 1 }, (done) => {

            const MockedAction = Proxyquire('../../../lib/command/actions', {
                '../agent': {
                    SESSION_ID: function () {

                        return 'id';
                    }
                },
                '../backend': {
                    rulespack: function () {

                        return Promise.resolve({ rules: [{ a: 1 }] });
                    }
                }
            });

            MockedAction.instrumentation_enable()
                .then((str) => {

                    expect(str).to.equal('');
                    done();
                });
        });

        it('should ask for a new rulespack', { plan: 1 }, () => {

            const MockedAction = Proxyquire('../../../lib/command/actions', {
                '../agent': {
                    SESSION_ID: function () {

                        return 'id';
                    }
                },
                '../backend': {
                    rulespack: function () {

                        return Promise.resolve({ pack_id: 10, rules: [{ a: 1 }] });
                    }
                },
                '../rules': {
                    enforceRuleList: function () {

                        return true;
                    }
                }
            });

            return MockedAction.instrumentation_enable()
                .then((id) => {

                    expect(id).to.equal(10);
                });
        });


        it('should remove all callbacks', { plan: 1 }, () => {

            const MockedAction = Proxyquire('../../../lib/command/actions', {
                '../instrumentation/patch': {
                    removeAllCallbacks: function () {

                        expect(true).to.be.true(); // ensure call
                    }
                }
            });

            return MockedAction.instrumentation_remove();
        });

        it('should remove all callbacks then logout', { plan: 2 }, () => {

            const MockedAction = Proxyquire('../../../lib/command/actions', {
                '../instrumentation/patch': {
                    removeAllCallbacks: function () {

                        expect(true).to.be.true(); // ensure call
                    }
                },
                '../agent': {
                    stop: function () {

                        expect(true).to.be.true(); // ensure call
                        return Promise.resolve();
                    }
                }
            });

            return MockedAction.force_logout();
        });
    });

    describe('features_change', () => {

        it('should change features', { plan: 1 }, (done) => {

            const MockedAction = Proxyquire('../../../lib/command/actions', {
                './features': {
                    change: function (params) {

                        expect(params).to.equal({});
                        done();
                    }
                }
            });
            MockedAction.features_change({});
        });
    });

    describe('features_get', () => {

        it('should change features', { plan: 1 }, (done) => {

            const MockedAction = Proxyquire('../../../lib/command/actions', {
                './features': {
                    read: function () {

                        return { hello: 'world' };
                    }
                }
            });
            MockedAction.features_get()
                .then((r) => {

                    expect(r).to.equal({ hello: 'world' });
                    done();
                });
        });
    });

    describe('paths_whitelist', () => {

        it('should reject without params', { plan: 1 }, (done) => {

            Action.paths_whitelist([], '')
                .catch((err) => {

                    expect(err).to.exist();
                    done();
                });
        });

        it('should change whitelist', { plan: 2 }, (done) => {

            const MockedAction = Proxyquire('../../../lib/command/actions', {
                '../instrumentation/whitelist': {
                    whitelistThesePaths: function (list) {

                        expect(list).to.exist();
                        expect(list).to.equal(['a']);
                        done();
                    }
                }
            });

            MockedAction.paths_whitelist([['a']], '');
        });
    });

    describe('ips_whitelist', () => {

        it('should change whitelist', { plan: 2 }, (done) => {

            const MockedAction = Proxyquire('../../../lib/command/actions', {
                '../instrumentation/whitelist': {
                    whitelistTheseIPs: function (list) {

                        expect(list).to.exist();
                        expect(list).to.equal(['a']);
                        done();
                    }
                }
            });

            MockedAction.ips_whitelist([['a']], '');
        });
    });

    describe('get_bundle', () => {

        it('should send the bundle to the BE', { plan: 2 }, (done) => {

            const MockedAction = Proxyquire('../../../lib/command/actions', {
                '../backend': {
                    bundle: function (_, resp) {

                        expect(resp.dependencies.length).to.be.above(250);
                        expect(resp.bundle_signature.length).to.equal(40);
                        done();
                    }
                }
            });

            MockedAction.get_bundle(null, 10);

        });

        it('should send the bundle to the BE w/o declared deps', { plan: 2 }, (done) => {

            const MockedAction = Proxyquire('../../../lib/command/actions', {
                '../backend/login': {
                    getPkg: () => null
                },
                '../backend': {
                    bundle: function (_, resp) {

                        expect(resp.dependencies.length).to.be.above(250);
                        expect(resp.bundle_signature.length).to.equal(40);
                        done();
                    }
                }
            });

            MockedAction.get_bundle(null, 10);

        });
    });
});
