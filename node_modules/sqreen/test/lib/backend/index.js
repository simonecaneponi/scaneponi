/**
 * Copyright (c) 2016 Sqreen. All Rights Reserved.
 * Please refer to our terms for more information: https://www.sqreen.io/terms.html
 */
'use strict';
const Code = require('code');
const Lab = require('lab');
const lab = exports.lab = Lab.script();

const describe = lab.describe;
const it = lab.it;
const expect = Code.expect;

const Proxyquire = require('proxyquire');
const Os = require('os');

let BackEnd;

describe('BackEnd', () => {

    describe('_LoggedRp', () => {

        it('should reject unhandled http verbs', { plan: 1, timeout: 15000 }, () => {

            BackEnd = require('../../../lib/backend');
            return BackEnd._LoggedRp({ method: 'PATCH' })
                .catch((err) => {

                    expect(err.message).to.equal('unhandled verb PATCH');
                    return Promise.resolve();
                });
        });
    });

    describe('login', () => {

        it('should login to a server', { plan: 16 }, (done) => {

            BackEnd = Proxyquire('../../../lib/backend', {
                './wreckAsPromised': {
                    POST: function (uri, options, pl) {

                        expect(uri).to.equal('https://back.sqreen.io/sqreen/v1/app-login');
                        expect(options.headers['x-api-key']).to.equal('token');

                        expect(pl).to.includes(['agent_type', 'agent_version', 'os_type', 'hostname', 'runtime_type', 'runtime_version', 'framework_type', 'framework_version', 'environment', 'various_infos']);
                        expect(pl.agent_type).to.equal('nodejs');
                        // expect(pl.agent_version).to.equal(require('../../../package.json').version);
                        expect(pl.hostname).to.equal(Os.hostname());
                        expect(pl.os_type).to.includes(Os.arch());
                        expect(pl.os_type).to.includes(Os.type());
                        expect(pl.runtime_type).to.equal('node');
                        expect(pl.runtime_version).to.equal(process.version);
                        expect(pl.framework_type).to.equal('');
                        expect(pl.framework_version).to.not.exist();
                        expect(pl.environment).to.equal('test');
                        // expect(pl.various_infos.declared_dependencies).to.equal(require('../../../package.json').dependencies);
                        // expect(pl.various_infos.declared_devdependencies).to.equal(require('../../../package.json').devDependencies);
                        expect(pl.various_infos).to.includes(['time', 'pid', 'euid', 'name']);
                        expect(pl.bundle_signature).to.be.a.string();
                        expect(pl.bundle_signature.length).to.equal(40);

                        return Promise.resolve({ status: true, session_id: 'session-key' });
                    }

                }
            });

            BackEnd.login('token')
                .then((token) => {

                    expect(token).to.equal('session-key');
                    done();
                })
                .catch((err) => console.log(err));
        });

        it('should login to a server on v1', { plan: 5 }, (done) => {

            const MockedBackend = Proxyquire('../../../lib/backend/index', {
                './wreckAsPromised': {
                    POST: function () {

                        return Promise.resolve({
                            status: true,
                            session_id: 'session-key',
                            commands: [{ name: 'a' }],
                            features: { myFeature: 'hello' },
                            rules: [{ name: 'rule' }],
                            pack_id: 'a'
                        });
                    }
                },
                '../command': {
                    execute: function (cmd) {

                        expect(cmd.name).to.equal('a');
                        return Promise.resolve();
                    }
                },
                '../command/features': {
                    change: function (ft) {

                        expect(ft.myFeature).to.equal('hello');
                    }
                },
                '../rules': {
                    enforceRuleList: function (list) {

                        expect(list[0].name).to.equal('rule');
                        expect(list[0].rulesPack).to.equal('a');
                    }
                }

            });

            MockedBackend.login('token')
                .then((token) => {

                    expect(token).to.equal('session-key');
                    done();
                });
        });

        it('should fail to login to a server', { plan: 1, timeout: 60000 }, (done) => {

            BackEnd = Proxyquire('../../../lib/backend', {
                './wreckAsPromised': {
                    POST: function () {

                        return Promise.reject({ status: false });
                    }
                },
                '../util': {
                    timeout: function () {

                        return Promise.resolve();
                    }
                }
            });


            BackEnd.login('token')
                .then(() => done(new Error('this should have failed')))
                .catch((err) => {

                    expect(err).to.exist();
                    done();
                });
        });

        it('should fail to login to a server because of bad token', { plan: 1, timeout: 60000 }, (done) => {

            BackEnd = Proxyquire('../../../lib/backend', {
                './wreckAsPromised': {
                    POST: function () {

                        return Promise.resolve({
                            message: {
                                error: 'Token validation failure'
                            },
                            status: false
                        });
                    }

                }
            });


            BackEnd.login('token')
                .then(() => {


                    done(new Error('this should have failed'));
                })
                .catch((err) => {

                    expect(err).to.exist();

                    done();
                });
        });
    });

    describe('logout', () => {

        it('should logout a user', { plan: 3 }, (done) => {

            BackEnd = Proxyquire('../../../lib/backend', {
                './wreckAsPromised': {
                    GET: function (uri, options) {

                        expect(uri).to.equal('https://back.sqreen.io/sqreen/v0/app-logout');
                        expect(options.headers['x-session-key']).to.equal('session');

                        return Promise.resolve({ status: true });
                    }

                }
            });


            BackEnd.logout('session')
                .then((response) => {

                    expect(response).to.exist();

                    done();
                })
                .catch((err) => {

                    done(err);
                });
        });

        it('should fail to logout a user because of error 500', { plan: 1, timeout: 300 }, (done) => {

            BackEnd = Proxyquire('../../../lib/backend', {
                './wreckAsPromised': {
                    GET: function () {

                        return Promise.reject({ status: false });
                    }
                },
                '../util': {
                    timeout: function () {

                        return Promise.resolve();
                    }
                }
            });

            BackEnd.logout('token')
                .then(() => {

                    done(new Error('this should have failed'));
                })
                .catch((err) => {

                    expect(err).to.exist();

                    done();
                });
        });

        it('should fail to logout a user because of false status in payload', { plan: 1, timeout: 30000 }, (done) => {

            BackEnd = Proxyquire('../../../lib/backend', {
                './wreckAsPromised': {
                    GET: function () {

                        return Promise.resolve({ status: false });
                    }
                }
            });

            BackEnd.logout('token')
                .then(() => {


                    done(new Error('this should have failed'));
                })
                .catch((err) => {

                    expect(err).to.exist();
                    done();
                });
        });
    });

    describe('others', () => {

        it('should test heartbeat', { plan: 5 }, () => {

            BackEnd = Proxyquire('../../../lib/backend', {
                './wreckAsPromised': {
                    POST: function (uri, options, pl) {

                        expect(uri).to.equal('https://back.sqreen.io/sqreen/v1/app-beat');
                        expect(options.headers['x-session-key']).to.equal('token');

                        expect(pl).to.exist();
                        expect(pl.command_results).to.exist();
                        expect(pl.metrics).to.exist();

                        return Promise.resolve({ status: true, session_id: 'session-key' });
                    }

                }
            });

            return BackEnd.heartBeat('token');
        });

        it('should test attack', { plan: 3 }, () => {

            BackEnd = Proxyquire('../../../lib/backend', {
                './wreckAsPromised': {
                    POST: function (uri, options, pl) {

                        expect(uri).to.equal('https://back.sqreen.io/sqreen/v0/attack');
                        expect(options.headers['x-session-key']).to.equal('token');

                        expect(pl).to.exist();

                        return Promise.resolve({ status: true, session_id: 'session-key' });
                    }

                }
            });

            return BackEnd.attack('token', {});
        });

        it('should test batch', { plan: 3 }, () => {

            BackEnd = Proxyquire('../../../lib/backend', {
                './wreckAsPromised': {
                    POST: function (uri, options, pl) {

                        expect(uri).to.equal('https://back.sqreen.io/sqreen/v0/batch');
                        expect(options.headers['x-session-key']).to.equal('token');

                        expect(pl).to.exist();

                        return Promise.resolve({ status: true, session_id: 'session-key' });
                    }

                }
            });

            return BackEnd.batch('token', {});
        });

        it('should test exception', { plan: 3 }, () => {

            BackEnd = Proxyquire('../../../lib/backend', {
                './wreckAsPromised': {
                    POST: function (uri, options, pl) {

                        expect(uri).to.equal('https://back.sqreen.io/sqreen/v0/sqreen_exception');
                        expect(options.headers['x-session-key']).to.equal('token');

                        expect(pl).to.exist();

                        return Promise.resolve({ status: true, session_id: 'session-key' });
                    }

                }
            });

            return BackEnd.exception('token', {});
        });

        it('should test commands', { plan: 3 }, () => {

            BackEnd = Proxyquire('../../../lib/backend', {
                './wreckAsPromised': {
                    POST: function (uri, options, pl) {

                        expect(uri).to.equal('https://back.sqreen.io/sqreen/v0/commands');
                        expect(options.headers['x-session-key']).to.equal('token');

                        expect(pl).to.exist();

                        return Promise.resolve({ status: true, session_id: 'session-key' });
                    }

                }
            });

            return BackEnd.commands('token', {});
        });

        it('should test bundle', { plan: 3 }, () => {

            BackEnd = Proxyquire('../../../lib/backend', {
                './wreckAsPromised': {
                    POST: function (uri, options, pl) {

                        expect(uri).to.equal('https://back.sqreen.io/sqreen/v0/bundle');
                        expect(options.headers['x-session-key']).to.equal('token');

                        expect(pl).to.exist();

                        return Promise.resolve({ status: true, session_id: 'session-key' });
                    }

                }
            });

            return BackEnd.bundle('token', { a: 1 });
        });

        it('should test metrics', { plan: 3 }, () => {

            BackEnd = Proxyquire('../../../lib/backend', {
                './wreckAsPromised': {
                    POST: function (uri, options, pl) {

                        expect(uri).to.equal('https://back.sqreen.io/sqreen/v0/metrics');
                        expect(options.headers['x-session-key']).to.equal('token');

                        expect(pl).to.exist();

                        return Promise.resolve({ status: true, session_id: 'session-key' });
                    }

                }
            });

            return BackEnd.metrics('token', {});
        });

        it('should test rulespack', { plan: 2 }, () => {

            BackEnd = Proxyquire('../../../lib/backend', {
                './wreckAsPromised': {
                    GET: function (uri, options) {

                        expect(uri).to.equal('https://back.sqreen.io/sqreen/v0/rulespack');
                        expect(options.headers['x-session-key']).to.equal('token');

                        return Promise.resolve({ status: true, session_id: 'session-key' });
                    }

                }
            });

            return BackEnd.rulespack('token');
        });
    });
});
